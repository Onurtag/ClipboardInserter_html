<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <!-- Title -->
        <title>Clipboard Inserter HTML Enhanced</title>
        <!-- Scary base64 encoded favicon (小) -->
        <link href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAK9WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDUgNzkuMTY0NTkwLCAyMDIwLzEyLzA5LTExOjU3OjQ0ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjIuMSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIxLTAzLTE1VDAzOjQyOjMzKzAzOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIxLTAzLTE1VDA0OjAxOjI1KzAzOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMS0wMy0xNVQwNDowMToyNSswMzowMCIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Y2VhOTk4YmYtZGI0Ny0zZTQ2LWFiMzctYzBjYjU4ZWM3NGVjIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6NzlmNzhhZmEtOThiYi0xZDRiLWE0MGQtNTFjNmNhMWRjN2I0IiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NjBlYjE5MGUtNjJmMy01MTRhLTgyMDYtNDNkMjU5ZTBiNGMwIiB0aWZmOk9yaWVudGF0aW9uPSIxIiB0aWZmOlhSZXNvbHV0aW9uPSI3MjAwMDAvMTAwMDAiIHRpZmY6WVJlc29sdXRpb249IjcyMDAwMC8xMDAwMCIgdGlmZjpSZXNvbHV0aW9uVW5pdD0iMiIgZXhpZjpDb2xvclNwYWNlPSI2NTUzNSIgZXhpZjpQaXhlbFhEaW1lbnNpb249IjI1NiIgZXhpZjpQaXhlbFlEaW1lbnNpb249IjI1NiI+IDxwaG90b3Nob3A6VGV4dExheWVycz4gPHJkZjpCYWc+IDxyZGY6bGkgcGhvdG9zaG9wOkxheWVyTmFtZT0i5bCPIiBwaG90b3Nob3A6TGF5ZXJUZXh0PSLlsI8iLz4gPC9yZGY6QmFnPiA8L3Bob3Rvc2hvcDpUZXh0TGF5ZXJzPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjYwZWIxOTBlLTYyZjMtNTE0YS04MjA2LTQzZDI1OWUwYjRjMCIgc3RFdnQ6d2hlbj0iMjAyMS0wMy0xNVQwMzo0MjozMyswMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1OGZhMGFlOC1mNjg3LTJmNGMtOGVmOS1lZWIxMzU0MTQ0OGMiIHN0RXZ0OndoZW49IjIwMjEtMDMtMTVUMDM6NTA6NTIrMDM6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMi4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MWY5YTE4NDQtYzViZC00MDRlLWE4MjktZDA1MzZmMmExZjllIiBzdEV2dDp3aGVuPSIyMDIxLTAzLTE1VDA0OjAxOjI1KzAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjIuMSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNvbnZlcnRlZCIgc3RFdnQ6cGFyYW1ldGVycz0iZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmNlYTk5OGJmLWRiNDctM2U0Ni1hYjM3LWMwY2I1OGVjNzRlYyIgc3RFdnQ6d2hlbj0iMjAyMS0wMy0xNVQwNDowMToyNSswMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjEgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxZjlhMTg0NC1jNWJkLTQwNGUtYTgyOS1kMDUzNmYyYTFmOWUiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozOGM3NzQ2Ny1hMDZlLTRlNGYtYTdmZC1hM2NkMzNlMWNjY2IiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2MGViMTkwZS02MmYzLTUxNGEtODIwNi00M2QyNTllMGI0YzAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4T8iuIAAAEf0lEQVRIx42WS1DTVxTG0ybhHd6EhLwghCS0U1H6oPShdqZSFaaCba0dRpjWUUdk1JmKnVrRoo0gCvJSwFbbqdNMS0csShACMQnBosUZFl246IKFCxYssmTh4t/vS29mIiSWxW8g957cc853zj03MuvpYVks1N8/igN6sAnsBSfASXAIVIIikAJksZD9j4MkUAoO5J+fuIk1L7GcGZk0XXD3Y30zyFqTg9LS0lXAIA18AM7zYKPRKGVlZUnmdWXL9qbrs3l99/dhzwDk4AWy4vuyyGjlQhJGrRIYQS24RgcZGRmSQqGQdK9vCZodrgkh1TqRRYaQi2e8+IwDcTg3deIL7wjdt4Im8HukA8MbFUHzOdcU1h3gU7BF2L8CtCBxpYNwMTeCL7RXZr/D31OioD3AtdrBmJeZgdbcgYfndN3TF/H/5yI4DVBEOqAcr4EGfZfvBvXlgZRB3+0fwfpUFAc+bf/snfx297jthDPw0qFL82iEYdgeFI2hCjmgXiAX1IAupO4xv7UtmJOTI+WXbw2+vL/1b11PwB/Fgd90YdJbvOPAE7VaLWk0Gsl2jIWfYVa7RPEVdKAENtAIhnhQZmamJJfLpezsbImfsT4TzQGy89vqmh+npKRI8fHxUsH7ny0iCzfsvwFlzCIsD3VzwLvHdrBznl9QKpWS8d3qpYK2cR/2AtEkwrrXcva2T2tbv0x77v+Xxf2fRRY6mag6P1wzXZwKmCv3PmE0SUlJUtHupn8Ml7weHhSjyKOGzns+657mx7SPyGISe1+BDTLRWl+CEUTj11hLlnlIenp6KBpN/wMWeSJKm97D+i+5g3/dYZFzDOan3AtngQYYxH6VTPRwh65n2kt5VCpVSJ6IXv+JkUZxwMwugx9RbF8484SEBMlS07gANUaxt58OPgFXqamhrCIYFxcnJScnS1YUD/IMsbPArRgXrY1oL//psh25MpeamhraZ00sZ24zw+N0UKvrDTgZfdhAjXSLWv6gQQv49jk3uRkcBddZbMrL7uM5dIimaaODnQVtd28Wb69f5CCj9iyuqd39m2jdkzEyYCGPi1nVApnclInFTktLk+wfH15AsQfp4G3ofwrtOEyv9u11i/j/Vu7VuRYxh/qAJ4YDRl8B6nAZf7A3dM4bLMVPCytqF4uP9s/h3MN0YAbvgT0wOm1uHbsByThfzmKtlwUGj1Y5cLh4oRrEWCjTDDzYx24iBa1jTn339DGsl8vEFNWK28x5VKkZeHiEhiiUJ/zIWL92BsIXUDgYh209KBTfL8GQ3Ia2rhYBrwd5K9+CdF4OthdfLcuG8mWOC0bOwxl96DJtqllC1/F+fCjmWIKYCHwX1CBTfI5/5kXjgsik3tgxNcRih6Nm+yYmJkocgnZ0nL7L3w67N3lQtNdw1YsmFpRiClahxTpYKE5WSmLaWL1k2dm4YEcjoAmcsNkB8hnUmhxESEWZSsBuXLS+QseoC3rfRfFdaMVf83pn2F1VItNUMe7X/qtC1IJa2sWvho9Er+8ST+irIktV+NV6Hv8CoQSxebdkGb0AAAAASUVORK5CYII=" rel="icon" type="image/png" />
        <script>

            const RELEASE_VERSION_NUMBER = "3.3.6";
            /*
            /////////////////////////////////////////////////////////////////////////
            ///                                                                   ///
            ///        Downloadable HTML for Clipboard Inserter (Enhanced)        ///
            ///                                                                   ///
            /////////////////////////////////////////////////////////////////////////
            

                ------ General Info ------

            ❗ The following Non-default Clipboard Inserter settings are NOT required but highly suggested:
            - element name: pre
            - container selector: #textlines

            You can switch to prepending mode by setting the "Scroll" button to top (Up arrow: ↑)
            (Or you can just use a modified Clipboard Inserter addon like: https://github.com/Onurtag/clipboard-inserter)

            Hover buttons to read their descriptions.
            Both appending and prepending should work for all buttons and functionality. (Even if you don't have a modified Clipboard Inserter)

            This page was made piece by piece for personal use.

            Keyboard shortcuts:
            - Alt + S: Toggle Editing
            - A few more shortcuts can be enabled using the options menu.

            ❗ All options can be changed using the top right mini buttons and the settings menu.

            - ❗ If you are using private browsing mode (or clearing history/cache/localstorage etc.), your settings (button states and hidden options) might not get saved. Just edit below variables directly.

            */

            //------ Default Options ------
            //You don't have to modify these values unless your browser is in permanent private browsing mode
            //All options can be changed using the top right mini buttons and the settings menu.
            //Read below for more info
            const settings = {
                //Top right buttons
                scrollOnNewline: "toBottom",
                pinningEnabled: false,
                editingEnabled: false,
                copyOnPageEnabled: false,
                //Settings menu
                notifyOnNewline: false,
                autoHideYomichan: true,
                overlayHotkeyEnabled: false,
                backlogHotkeyEnabled: false,
                addNewLineHotkeyEnabled: false,
                purge500LinesWhen: 0,
                customFontSize: "30px",
                customFontSizeEnabled: false,
                customFontSizeOverlay: "40px",
                customFontSizeOverlayEnabled: false,
                //Regex
                regexEnabled: false,
                regexFilterMatch: "/.*onlykeep(.*)between.*/gim",
                regexFilterReplace: "$1",
                //Currently testing
                bgHotkeyEnabled: false,
                hoverScrollEnabled: false,
                hoverScrollSpeed: 108,
                //Debugging
                debuggingEnabled: false
            };
            //------ Explanation ------
            /**
             * autoHideYomichan
             *
             * true: Hides all yomichan/yomitan popups when your mouse leaves the window
             * false: disabled
             * ❗ This option requires the setting "Use a secure container around popups" to be off in yomichan's options.
             *
             * */
            /**
             * purge500LinesWhen
             *
             * Purges oldest 500 lines when you go over this amount (which can keep the page smooth).
             *
             * 0: disabled
             * Any number other than 0: enabled
             *
             * */
            /**
             * notifyOnNewline
             *
             * Whenever a new line is added; the symbol ✔ will flash on the window's title for a short time
             *
             * */
            /**
             * overlayHotkeyEnabled
             *
             * Enables the "Toggle overlay mode" hotkey "Alt + 0", "Ctrl + Alt + 0" or "}"
             *
             * This setting just adds a hotkey for the overlay mode feature. You can still use the toggle overlay mode button without enabling this hotkey.
             *
             * */

            /**
             * backlogHotkeyEnabled (For Overlay mode)
             *
             * Enables the "Toggle backlog mode" hotkey "Alt + O"
             *
             * This setting just adds a hotkey for the backlog mode feature. You can still use the backlog mode button without enabling this hotkey.
             *
             * */

            /**
             * bgHotkeyEnabled (currently abandoned. It has no real use.)
             *
             * Enables the "Toggle background color" hotkey "|"
             *
             * */
            /**
             * hoverScrollEnabled (currently testing.)
             *
             * When enabled you can scroll within the same line when you hover the "Scroll Down" "Scroll Up" overlay mode buttons.
             *
             * */
            /**
             * pinningEnabled
             *
             * true: pinning is enabled by default, false: disabled
             *
             * */

            /**
             * editingEnabled
             *
             * true: editing is enabled by default, false: disabled
             *
             * */
            //---------------------

            const historystack = [];
            const historystack_forward = [];
            const purged_lines = [];
            const maxhistorylength = 500;
            let overlayModeEnabled = false;
            let overlayModeBacklog = false;
            let forgiveHistoryTimes = 0;
            let linecount = 0;
            let editPinnedButtons = false;
            let textlinesTempVisible = false;
            let isChromium = window.chrome ? true : false;
            let regexMatchCompiled = null;
            let hoverTarget = null;
            let forgiveCopyArray = [];
            let pageTitle = document.title;

            //DOMContentLoaded Start (first load)
            document.addEventListener("DOMContentLoaded", function (event) {
                //Load settings from localstorage
                loadSettings();

                //Show error notifications if the setting is turned on
                setDebugState();

                //Load scroll button state (to top/to bottom/disabled)
                setScrollButton();

                //Document Title is different for local and online pages. Timeout is here so we can notice page refreshes from the page title.
                setTimeout(() => {
                    if (document.location.protocol.includes("http")) {
                        document.title = pageTitle = pageTitle + " (Online)";
                    } else {
                        document.title = pageTitle = pageTitle + " (Local)";
                    }
                    console.log(`%c${document.title}%c version ${RELEASE_VERSION_NUMBER}`, 'font-size:20px;color:#FF9800;', 'font-size:20px;color:#3BFB3B;');
                }, 170);

                //load first states for top right buttons
                if (settings.pinningEnabled) {
                    togglePinning(true);
                }
                if (settings.editingEnabled) {
                    toggleEditing(true);
                }
                if (settings.copyOnPageEnabled) {
                    toggleCopying(true);
                }

                //Create movable hover buttons
                createHoverButtons();

                //scroll_button
                document.getElementById("scroll_button").addEventListener("click", function () {
                    switch (settings.scrollOnNewline) {
                        case "disabled":
                            settings.scrollOnNewline = "toBottom";
                            break;
                        case "toBottom":
                            settings.scrollOnNewline = "toTop";
                            break;
                        case "toTop":
                            settings.scrollOnNewline = "disabled";
                            break;
                        default:
                            settings.scrollOnNewline = "toBottom";
                            break;
                    }
                    setScrollButton();
                    saveSettings("scrollOnNewline");
                });

                document.getElementById("remove_button").addEventListener("click", function () {
                    //Check if there are any lines.
                    if (linecount > 0) {
                        historyPush();

                        //If in overlay mode, remove the hover target.
                        if (overlayModeEnabled && !overlayModeBacklog) {
                            removeLine(hoverTarget);
                        } else {
                            //Remove the first/last line.
                            switch (settings.scrollOnNewline) {
                                case "disabled":
                                    document.querySelector("#textlines > pre:last-of-type").remove();
                                    break;
                                case "toBottom":
                                    document.querySelector("#textlines > pre:last-of-type").remove();
                                    break;
                                case "toTop":
                                    document.querySelector("#textlines > pre:first-of-type").remove();
                                    break;
                                default:
                                    break;
                            }

                            updateCounter();
                        }
                    }
                });

                document.getElementById("clear_button").addEventListener("click", function (e) {
                    //If shift is held, clear history as well.
                    if (e.shiftKey) {
                        historystack.length = 0;
                        historystack_forward.length = 0;
                        setHistoryButtons();
                    } else {
                        historyPush();
                    }

                    document.querySelector("#textlines").innerHTML = "";
                    //Update the counter.
                    updateCounter();
                });

                document.getElementById("go_to_last_button").addEventListener("click", function () {
                    //document.querySelector("#textlines > pre:last-of-type").scrollIntoView();
                    if (linecount > 0) {
                        doScroll(0, findPos(document.querySelector("#textlines > pre:last-of-type")).top - 200);
                    }
                });

                document.getElementById("go_bottom_button").addEventListener("click", function () {
                    if (linecount > 0) {
                        scrollTopBottom("bottom");
                    }
                });

                //Keyboard shortcuts
                document.addEventListener("keydown", function (e) {
                    //Alt + S: Toggle Editing (enabled by default)
                    if (e.altKey && e.key.toLowerCase() == "s") {
                        toggleEditing();
                        e.preventDefault();
                        //Alt + O: Toggle Backlog mode when the overloy mode is on (disabled by default)
                    } else if (e.altKey && e.key.toLowerCase() == "o") {
                        if (overlayModeEnabled && settings.backlogHotkeyEnabled) {
                            toggleBacklogMode();
                            e.preventDefault();
                        }
                        //Alt + E: Add a new line (disabled by default)
                    } else if (e.altKey && e.key.toLowerCase() == "e") {
                        if (settings.addNewLineHotkeyEnabled) {
                            addNewLine();
                            e.preventDefault();
                        }
                        //Alt + 0, Ctrl + Alt + 0 or '}' key: Toggle Overlay mode (disabled by default)
                    } else if ((e.altKey && e.key.toLowerCase() == "0") || e.key == "}") {
                        if (settings.overlayHotkeyEnabled) {
                            toggleOverlayMode();
                            e.preventDefault();
                        }
                        //"|" key: Toggle background color (disabled by default)
                    } else if (e.key == "|") {
                        if (settings.bgHotkeyEnabled) {
                            toggleBackgroundColor();
                            e.preventDefault();
                        }
                    }
                });

                //Non-css hover method for the menu
                document.getElementById("menucontainer").addEventListener("mouseenter", function (e) {
                    handleMenuState();
                });

                document.getElementById("toprightbuttons").addEventListener("mouseleave", function (e) {
                    if (!settings.pinningEnabled) {
                        //document.querySelector("#menucontainer").removeAttribute("style");
                        handleMenuState();
                    }
                });

                //start checking for mouse in/out
                checkMouseInOut();

                /**
                 * Start detecting hover targets so we can move the hover buttons
                 */
                document.addEventListener("mouseover", function (e) {
                    const textlines_Node = document.querySelector("#textlines");
                    let currentElement = e.target;

                    const closest = currentElement.closest("#textlines > pre");
                    //enter #textlines > pre *
                    if (closest) {
                        //Move hover buttons to target
                        moveHoverButtons(closest);

                        //enter anything except the hover buttons (or #textlines > pre * above)
                    } else if (!currentElement.closest(".hoverButtonsBackground")) {
                        //Hide hover buttons
                        moveHoverButtons(null);
                    }
                });

                /**
                 * Use the settings.copyOnPageEnabled variable to handle if we should insert text that was copied on this page into a new line
                 */
                const INSERTER_MAX_DELAY = 550;
                function copyncutHandler(event) {
                    if (settings.copyOnPageEnabled == false) {
                        //Change selection color using css and remove after 100ms
                        document.body.classList.add("selectioncopied");
                        setTimeout(() => {
                            document.body.classList.remove("selectioncopied");
                        }, 150);

                        //We use the text content to detect this as a simpler system would make a mistake if some other automated text was inserted between the copy event and the insertion by the extension.
                        const selectedText = document.getSelection().toString();
                        const selectedTextTrimmed = selectedText.trim();
                        //Clipboard Inserter might or might not trim the copied text (depending on extension)
                        forgiveCopyArray.push(selectedText);
                        if (selectedText != selectedTextTrimmed) {
                            forgiveCopyArray.push(selectedTextTrimmed);
                        }
                        //The following is here to prevent the situation where the copy/cut event is ran; but the inserter doesn't insert the copied text (i.e. as it is identical to the current clipboard content)
                        //Also cleans up the remaining trimmed/non-trimmed text
                        setTimeout(() => {
                            if (forgiveCopyArray.length > 0) {
                                //Remove regular and trimmed text from the array
                                const strindex = forgiveCopyArray.indexOf(selectedText);
                                if (strindex !== -1) {
                                    forgiveCopyArray.splice(strindex, 1);
                                }
                                const trimstrindex = forgiveCopyArray.indexOf(selectedTextTrimmed);
                                if (trimstrindex !== -1) {
                                    forgiveCopyArray.splice(trimstrindex, 1);
                                }
                            }
                        }, INSERTER_MAX_DELAY);
                    }
                }
                //Listen to copy and cut events
                document.addEventListener("copy", copyncutHandler);
                document.addEventListener("cut", copyncutHandler);

                /**
                 * Listen to paste event
                 * Non-Chromium only (Firefox doesn't have contenteditable="plaintext-only")
                 * (Note: this moves the caret)
                 * //TODO: Firefox 115 might have fixed this
                 */
                if (isChromium == false) {
                    document.querySelector("#textlines").addEventListener("paste", function (e) {
                        const target = e.target;
                        if (target.nodeName == "PRE" && target.hasAttribute("contenteditable")) {
                            //do action after the event is done
                            setTimeout(() => {
                                //If target has a child (i.e. html was pasted)
                                if (target.firstElementChild) {
                                    //get innerText and set textContent (avoids <br>'s)
                                    const text = target.innerText;
                                    target.textContent = text;
                                }
                            }, 1);
                        }
                    });
                }

                //main mutation observer for new lines.
                const textlinesMutationObserver = new MutationObserver(function (records) {
                    records.forEach(function (mutation) {
                        mutation.addedNodes.forEach(function (node) {
                            try {
                                let nodeText = node.textContent;
                                //If the inserted text was copied on this page, do not insert it. (depending on the current setting)
                                if (forgiveCopyArray.length > 0 && forgiveCopyArray.includes(nodeText)) {
                                    const strindex = forgiveCopyArray.indexOf(nodeText);
                                    if (strindex !== -1) {
                                        forgiveCopyArray.splice(strindex, 1);
                                    }
                                    //Remove the node (never appears on the page)
                                    node.remove();
                                    return;
                                }

                                //Compatibility for prepending because most people aren't using an upgraded clipboard inserter add-on that allows prepending.
                                switch (settings.scrollOnNewline) {
                                    case "toTop":
                                        let nextSib = node.nextElementSibling;
                                        //detect an append() (should have been a prepend)
                                        if (nextSib == null && forgiveHistoryTimes == 0 && linecount > 0) {
                                            document.querySelector("#textlines").prepend(node);
                                            return;
                                        }
                                    default:
                                        break;
                                }

                                //push history (clears forward history)
                                if (forgiveHistoryTimes == 0) {
                                    historyPush();
                                } else {
                                    --forgiveHistoryTimes;
                                }

                                //Why use inner pre? 1) Double/Triple click selection breaks without it. 2) Editable outlines look much better.
                                //Check if the node is a history node that already has the inner pre
                                let innerPre = node.querySelector("pre");
                                const contenteditableValue = isChromium ? "plaintext-only" : "true";
                                if (innerPre == null) {
                                    //Not a history node

                                    //check if editing is enabled
                                    let preNodeOpen = settings.editingEnabled ? `<pre contenteditable="${contenteditableValue}">` : "<pre>";

                                    //Regex replace if its enabled
                                    if (settings.regexEnabled) {
                                        //Use compiled regex
                                        nodeText = nodeText.replace(regexMatchCompiled, settings.regexFilterReplace);
                                    }
                                    //put the added pre text into another pre so we can modify it later on.
                                    node.innerHTML = preNodeOpen + "</pre>";
                                    node.firstChild.textContent = nodeText;
                                } else {
                                    //History node. No need to add inner pre.
                                    if (settings.editingEnabled) {
                                        innerPre.setAttribute("contenteditable", contenteditableValue);
                                    }
                                }

                                //Skip some steps while loading history
                                if (forgiveHistoryTimes == 0) {
                                    //Overlay mode
                                    if (overlayModeEnabled) {
                                        //If text lines were temporarily made visible, hide them.
                                        if (textlinesTempVisible) {
                                            toggleTextVisibility("temp_hide");
                                        }
                                    }
                                    //update counter
                                    updateCounter();

                                    //purge 500 lines if its enabled.
                                    if (settings.purge500LinesWhen && linecount > settings.purge500LinesWhen) {
                                        purgeExtraLines();
                                    }

                                    //Notify on new line if its enabled (using document.title)
                                    if (settings.notifyOnNewline && !overlayModeEnabled && document.querySelector("html:hover") == null) {
                                        notifyUsingTitle();
                                    }

                                    //Scroll to the top/bottom based on the current setting
                                    doScrollOnNewline();
                                }
                            } catch (error) {
                                console.error(error);
                            }
                        });
                    });
                });

                //mutation observer for compatibility. Because not everyone is willing to change their extension's options. (read the readme above)
                const compatibilityMutationObserver = new MutationObserver(function (records) {
                    records.forEach(function (mutation) {
                        mutation.addedNodes.forEach(function (node) {
                            try {
                                //Everything other than "body > p" is ignored. (second part might be useless)
                                if (node.tagName != "P" || node.parentNode.tagName != "BODY") {
                                    return;
                                }

                                //Get the new text
                                let newNode = document.createElement("pre");
                                newNode.textContent = node.textContent;

                                //Remove the node (never appears on the page)
                                node.remove();

                                //Append or prepend the new node depending on the current setting
                                switch (settings.scrollOnNewline) {
                                    case "disabled":
                                        document.querySelector("#textlines").append(newNode);
                                        break;
                                    case "toBottom":
                                        document.querySelector("#textlines").append(newNode);
                                        break;
                                    case "toTop":
                                        document.querySelector("#textlines").prepend(newNode);
                                        break;
                                    default:
                                        document.querySelector("#textlines").append(newNode);
                                        break;
                                }
                            } catch (error) {
                                console.error(error);
                            }
                        });
                    });
                });

                //start the textlines mutation observer
                textlinesMutationObserver.observe(document.querySelector("#textlines"), {
                    childList: true,
                    subtree: false,
                });

                //start the default options compatibility mutation observer
                compatibilityMutationObserver.observe(document.querySelector("body"), {
                    childList: true,
                    subtree: false,
                });
            });
            //---DOMContentLoaded end---
            //---DOMContentLoaded end---
            //---DOMContentLoaded end---

            //----------functions----------

            /**
             * Open settings menu.
             * Input ids are used to save the new data to the settings object.
             * */
            function openSettingsMenu() {
                const settingsHTML = `
<div id="settingsContainer">
    <div id="settingsBackground" title="Close" onclick="menuClose(false)"></div>
    <div id="settingsWindow">
        <h2 style="text-align: center;margin: 0.4em 0 0 0;">Settings</h2>
        <h5 style="text-align: center;margin: 0 0 0.5em 0;">(version ${RELEASE_VERSION_NUMBER})</h5>
        <div class="settingCloseButton" title="Close" onclick="menuClose(false)">
            <!-- Octicons, License: MIT, https://github.com/primer/octicons/ -->
            <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16">
                <path fill="currentColor" fill-rule="evenodd" d="M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.75.75 0 1 1 1.06 1.06L9.06 8l3.22 3.22a.75.75 0 1 1-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 0 1-1.06-1.06L6.94 8L3.72 4.78a.75.75 0 0 1 0-1.06z"></path>
            </svg>
        </div>
        <input type="checkbox" id="customFontSizeEnabled" ${settings.customFontSizeEnabled ? "checked" : ""}>
        <label for="customFontSize">Custom font size:</label>
        <input type="text" id="customFontSize" value="${settings.customFontSize}" style="width:40px;">
        <span title="Custom font sizes. Some examples: 16pt, 22px, 2em etc...
Leave the field empty to use default font size." class="settingTooltip">?</span>
        <br>
        <input type="checkbox" id="customFontSizeOverlayEnabled" ${settings.customFontSizeOverlayEnabled ? "checked" : ""}>
        <label for="customFontSizeOverlay">Overlay mode custom font size:</label>
        <input type="text" id="customFontSizeOverlay" value="${settings.customFontSizeOverlay}" style="width:40px;">
        <span title="Custom font sizes. Some examples: 16pt, 22px, 2em etc...
Leave the field empty to use default font size." class="settingTooltip">?</span>
        <br>

        <input type="checkbox" id="notifyOnNewline" ${settings.notifyOnNewline ? "checked" : ""}>
        <label for="notifyOnNewline">Notify on new line</label>
        <span title="Whenever a new line is added; the symbol ✔ will flash on the window's title for a short time.\nDisabled in Overlay Mode." class="settingTooltip">?</span>
        <br>

        <input type="checkbox" id="autoHideYomichan" ${settings.autoHideYomichan ? "checked" : ""}>
        <label for="autoHideYomichan">Auto-hide Yomichan/Yomitan popups</label>
        <span title="Hides all yomichan/yomitan popups when your mouse leaves the window.
!!! This option requires the setting 'Use a secure container around popups' to be off in yomichan/yomitan options." class="settingTooltip">?</span>
        <br>
        <br>

        <input type="checkbox" id="overlayHotkeyEnabled" ${settings.overlayHotkeyEnabled ? "checked" : ""}>
        <label for="overlayHotkeyEnabled">"Overlay mode" hotkey enabled</label>
        <span title="Enables the 'Toggle overlay mode' hotkey 'Alt + 0', 'Ctrl + Alt + 0' or '}'" class="settingTooltip">?</span>
        <br>

        <input type="checkbox" id="backlogHotkeyEnabled" ${settings.backlogHotkeyEnabled ? "checked" : ""}>
        <label for="backlogHotkeyEnabled">"Backlog mode" hotkey enabled</label>
        <span title="Enables the 'Toggle backlog mode' hotkey 'Alt + O'" class="settingTooltip">?</span>
        <br>

        <input type="checkbox" id="addNewLineHotkeyEnabled" ${settings.addNewLineHotkeyEnabled ? "checked" : ""}>
        <label for="addNewLineHotkeyEnabled">"Add a new line" hotkey enabled</label>
        <span title="Enables the 'Add a new line' hotkey 'Alt + E'" class="settingTooltip">?</span>
        <br>

        <input type="checkbox" id="bgHotkeyEnabled" ${settings.bgHotkeyEnabled ? "checked" : ""}>
        <label for="bgHotkeyEnabled">"Toggle BG color" hotkey enabled</label>
        <span title="(Currently testing) Enables the 'Toggle background color' hotkey '|'" class="settingTooltip">?</span>
        <br>
        <input type="checkbox" id="hoverScrollEnabled" ${settings.hoverScrollEnabled ? "checked" : ""}>
        <label for="hoverScrollEnabled">Overlay mode hover scroll enabled.</label>
        <label for="hoverScrollSpeed">Speed:</label>
        <input type="number" id="hoverScrollSpeed" min="1" max="1000" value="${settings.hoverScrollSpeed}" style="width:80px;">
        <span title="(Currently testing) When enabled you can scroll within the same line when you hover the 'Scroll Down' 'Scroll Up' overlay mode buttons." class="settingTooltip">?</span>
        <br>
        <br>

        <input type="checkbox" id="regexEnabled" ${settings.regexEnabled ? "checked" : ""}>
        <label for="regexEnabled">Enable regex replacer</label>
        <span title="Enables the regex replacer which uses below two inputs." class="settingTooltip">?</span>
        <br>
        <label for="regexFilterMatch">Regex match string:</label>
        <input type="text" id="regexFilterMatch" value="${settings.regexFilterMatch}" style="width:220px;">
        <span title="Regex match string. Example: /your_regex/gim
For testing use https://regex101.com and select javascript flavor and turn on substitution mode." class="settingTooltip">?</span>
        <br>
        <label for="regexFilterReplace">Regex replace string:</label>
        <input type="text" id="regexFilterReplace" value="${settings.regexFilterReplace}" style="width:220px;">
        <span title="Regex replace string. Example: $1
For testing use https://regex101.com and select javascript flavor and turn on substitution mode." class="settingTooltip">?</span>
        <br>
        <br>

        <label for="purge500LinesWhen">Purge 500 lines when over:</label>
        <input type="number" id="purge500LinesWhen" min="0" max="10000" value="${settings.purge500LinesWhen}" style="width:80px;">
        <span title="Purges oldest 500 lines when you go over this amount (which can keep the page smooth). I use 1500.
Setting this to 0 disables purging lines.
You can access the list of purged lines by typing 'purged_lines' in your browser console." class="settingTooltip">?</span>
        <br>
        <br>

        <input type="checkbox" id="debuggingEnabled" ${settings.debuggingEnabled ? "checked" : ""}>
        <label for="debuggingEnabled">Show error notifications</label>
        <span title="Shows simple error notifications when enabled." class="settingTooltip">?</span>
        <br>
        <br>

        <!--
        <div style="font-size: 10pt;opacity:0.7;text-align: center;line-height: 10pt;">Settings will be reset if you clear browser data.</div>
        -->
        <button onclick="menuClose()">Save & Close</button>
    </div>
</div>`;
                document.body.insertAdjacentHTML("beforeend", settingsHTML);
            }

            function menuClose(save = true) {
                let settingsContainer = document.querySelector("#settingsContainer");
                if (save) {
                    //Save each type of setting
                    settingsContainer.querySelectorAll("input").forEach((input) => {
                        switch (input.type) {
                            case "checkbox":
                                settings[input.id] = input.checked;
                                break;

                            case "number":
                                settings[input.id] = input.valueAsNumber;
                                break;

                            //string inputs
                            default:
                                settings[input.id] = input.value;
                                break;
                        }
                    });
                    //Save settings to localStorage
                    saveSettings();
                    //Apply the newly saved settings
                    loadSettings(true);
                }
                settingsContainer.remove();
            }

            /**
             * Set scroll button state
             * */
            function setScrollButton() {
                switch (settings.scrollOnNewline) {
                    case "disabled":
                        document.querySelector("#scroll_button").classList.value = ["no_scroll"];
                        break;
                    case "toBottom":
                        document.querySelector("#scroll_button").classList.value = ["to_bottom"];
                        break;
                    case "toTop":
                        document.querySelector("#scroll_button").classList.value = ["to_top"];
                        break;
                    default:
                        settings.scrollOnNewline = "toBottom";
                        break;
                }
            }

            /**
             * Set hover target and Move Hover buttons
             * */
            function moveHoverButtons(newTarget) {
                let hoverButtonsNode = getHoverButtons();
                if (newTarget != null) {
                    //Set new target
                    hoverTarget = newTarget;
                    //Move hover buttons (except for overlaymode)
                    if (!overlayModeEnabled || overlayModeBacklog) {
                        let targetXY = findPos(hoverTarget);
                        hoverButtonsNode.style.setProperty("left", `${targetXY.left}px`);
                        hoverButtonsNode.style.setProperty("top", `${targetXY.top}px`);
                    }
                    //Unhide hover buttons (except when textlines are hidden)
                    if (!document.querySelector("#textlines").classList.contains("hidden")) {
                        hoverButtonsNode.classList.remove("hidden");
                    }
                } else {
                    //Don't hide in overlay mode
                    if (!overlayModeEnabled || overlayModeBacklog) {
                        hoverButtonsNode.classList.add("hidden");
                    }
                }
            }

            /**
             * Compile regex
             * */
            function compileRegex() {
                if (settings.regexFilterMatch != "") {
                    //If the regex doesn't match the /str/gim format (== null), use the string itself to create an identical array.
                    let matches = settings.regexFilterMatch.match("\/(.*)\/(.*)") || ["", settings.regexFilterMatch, ""];
                    regexMatchCompiled = new RegExp(matches[1], matches[2]);
                }
            }

            /**
             * Set custom font sizes from options
             * */
            function setCustomFontSizes() {
                //Use a giga template
                const customStyleHTML = `
                <style id="customFontSizes">
                    ${settings.customFontSizeEnabled ? `
                        body {
                            font-size: ${settings.customFontSize};
                        }
                    ` : ""}

                    ${settings.customFontSizeOverlayEnabled ? `
                        html.overlaymode #textlines > pre > pre {
                            font-size: ${settings.customFontSizeOverlay};
                        }
                    ` : ""}
                </style>
                `;
                let styleNode = document.querySelector("#customFontSizes");
                if (styleNode) {
                    styleNode.remove();
                }
                document.head.insertAdjacentHTML("beforeend", customStyleHTML);
            }

            /**
             * Debugging stuff
             * */
            function setDebugState() {
                if (settings.debuggingEnabled) {
                    //Show simple debugging notifications.
                    window.addEventListener("error", (e) => {
                        const notification = document.createElement("div");
                        notification.textContent = `Error: ${e.message}.\n\nFor more info check the console.`;
                        Object.assign(notification.style, { position: "fixed", bottom: "10px", right: "10px", background: "#f44336", color: "white", padding: "10px", borderRadius: "5px", zIndex: 1000, boxShadow: "0 2px 5px rgba(0, 0, 0, 0.3)", whiteSpace: "pre-line"});
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 10000);
                        console.error(e.message, {error: e});
                        return false;
                    });
                }
            }

            /**
             * Load settings from localstorage
             * */
            function loadSettings(useCurrent = false) {
                if (!useCurrent) {
                    Object.entries(settings).forEach(([key, value]) => {
                        settings[key] = getIfInLocalStorage(key, value);
                    });
                    //parse integers (i.e. handle everything that isn't a string or a boolean)
                    settings.purge500LinesWhen = parseInt(settings.purge500LinesWhen);
                }
                //Compile regex
                compileRegex();
                //Set custom font sizes
                setCustomFontSizes();
            }

            /**
             * Saves setting to localstorage
             * */
            function saveSettings(keyString = null) {
                //save all or just a specific setting
                if (keyString == null) {
                    Object.entries(settings).forEach(([key, value]) => {
                        localStorage.setItem(key, value);
                    });
                } else {
                    localStorage.setItem(keyString, settings[keyString]);
                }
            }

            /**
             * Load setting from localstorage if it exists, otherwise keep current value.
             * Parses "true" and "false".
             * */
            function getIfInLocalStorage(itemName, currentVal) {
                let storedVal = localStorage.getItem(itemName);
                if (storedVal != null) {
                    //If the stored value is true or false return the boolean value.
                    switch (storedVal.toLowerCase()) {
                        case "true":
                            return true;
                        case "false":
                            return false;
                        default:
                            return storedVal;
                    }
                } else {
                    //No stored value
                    return currentVal;
                }
            }

            /**
             * Inserts dummy lines for testing.
             * amount (optional): number
             * method (optional): insertAdjacentHTML method. Default "afterbegin"
             * */
            function debugInsertLines(amount = 50, method = null) {
                let textlines = document.querySelector("#textlines");
                for (let index = 0; index < amount; index++) {
                    setTimeout(() => {
                        textlines.insertAdjacentHTML(method || "afterbegin", `<pre>${index + 1} 華鳥風月</pre>`);
                    }, index * 10);
                }
            }

            //Modified from https://stackoverflow.com/a/24989958/5050478
            //Used for "auto hide yomichan popup" (with shadow dom disabled in settings)
            //Also used to hide hover buttons automatically
            function checkMouseInOut() {
                var theTimer;
                var aFrameWasHidden = false;

                //Reset or clear the timer on mouse in/out events
                window.onmouseout = resetTimer;
                window.onmouseover = clearTimer;

                function doAction() {
                    try {
                        //Hide any visible yomichan popups
                        let yomichanFrames = document.querySelectorAll("iframe.yomichan-popup, iframe.yomitan-popup");
                        yomichanFrames.forEach((currFrame) => {
                            if (currFrame.style.getPropertyValue("visibility") == "visible") {
                                //Use display property (yomichan uses visibility)
                                currFrame.style.setProperty("display", "none");
                                currFrame.classList.add("thisFrameWasHidden");
                                aFrameWasHidden = true;
                            }
                        });
                    } catch (error) {
                        console.error(error);
                    }
                }

                function clearTimer(e) {
                    //Mouse entered the window or any element
                    clearTimeout(theTimer);
                    try {
                        //Unhide yomichan popups after 350ms (give the popup some time to hide)
                        if (aFrameWasHidden) {
                            setTimeout(() => {
                                let hiddenFrames = document.querySelectorAll("iframe.yomichan-popup.thisFrameWasHidden, iframe.yomitan-popup.thisFrameWasHidden");
                                hiddenFrames.forEach((currFrame) => {
                                    currFrame.style.removeProperty("display");
                                    currFrame.classList.remove("thisFrameWasHidden");
                                });
                                aFrameWasHidden = false;
                            }, 350);
                        }
                    } catch (error) {
                        console.error(error);
                    }
                }

                function resetTimer(e) {
                    clearTimeout(theTimer);
                    let reltarget = e.relatedTarget || e.toElement;
                    if (!reltarget || (reltarget.nodeName == "HTML" && e.target == document.firstChild)) {
                        //Cursor left the window.

                        //If not in overlay mode: Hide hover buttons
                        if (!overlayModeEnabled) {
                            getHoverButtons().classList.add("hidden");
                        }
                        //Hide yomichan popups N ms after the cursor leaves the window
                        if (settings.autoHideYomichan) {
                            theTimer = setTimeout(doAction, 300);
                        }
                    }
                }
            }

            //handle top right menu container hover state manually (required to support keybindings and transparency)
            function handleMenuState() {
                var menuStyles = window.getComputedStyle(document.querySelector("#menucontainer"));
                var buttonsStyles = window.getComputedStyle(document.querySelector("#toprightbuttons"));
                var menuDisplay = menuStyles.getPropertyValue("display");
                var buttonsDisplay = buttonsStyles.getPropertyValue("display");
                if (menuDisplay == "block" && buttonsDisplay == "block") {
                    document.querySelector("#menucontainer").setAttribute("style", "display:none;");
                } else if (menuDisplay == "none" && buttonsDisplay == "none") {
                    document.querySelector("#menucontainer").removeAttribute("style");
                }
            }

            //Firefox hover bug workaround: Recheck the menu state when its hidden to prevent it from being hidden permanently.
            let menustateInterval = setInterval(() => {
                //Check when not pinned and hidden manually
                if (!settings.pinningEnabled && document.querySelector('#menucontainer[style="display:none;"]')) {
                    handleMenuState();
                }
            }, 175);

            //Create hover buttons (then we move it)
            function createHoverButtons() {
                let hoverButtons = document.createElement("div");
                document.body.append(hoverButtons);
                //Basicons svg from https://basicons.xyz/, License: MIT
                hoverButtons.outerHTML = `
            <div class="hoverButtonsBackground hidden">
            <div class="hoverButtons hoverButtonDelete" title="Remove line"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M5 5L19 19M5 19L19 5"></path>
                </svg></div>
            <div class="hoverButtons hoverButtonReduceNewlines" title="Reduce newlines and spaces
(Alt+Click: Remove all spaces & tabs as well)"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M 3 3 L 21 3"></path>
                <path class="middle" d="M 3 9 L 21 9 "></path>
                <path d="M 3 15 L 21 15"></path>
            </svg></div>
            <div class="hoverButtons hoverButtonCopy" title="Copy to clipboard"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M 8 6 H 16 M 8 10 H 16 M 8 14 H 12 M 6 22 H 18 C 20 22 20 22 20 20 V 4 C 20 2 20 2 19 2 H 6 C 4 2 4 2 4 4 V 20 C 4 22 4 22 6 22 Z"></path>
                </svg></div>
            <div class="hoverButtons hoverButtonDown" title="Scroll down one line"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 21V3M12 3L5 10M12 3L19 10"></path>
                </svg></div>
            <div class="hoverButtons hoverButtonUp" title="Scroll up one line"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 21V3M12 3L5 10M12 3L19 10"></path>
                </svg></div>
            </div>`;

                document.querySelector(".hoverButtonsBackground .hoverButtonDelete").addEventListener("click", function (event) {
                    historyPush();

                    removeLine(hoverTarget);
                });
                document.querySelector(".hoverButtonsBackground .hoverButtonReduceNewlines").addEventListener("click", function (event) {
                    historyPush();

                    reduceNewlines(hoverTarget, event);
                });
                document.querySelector(".hoverButtonsBackground .hoverButtonUp").addEventListener("click", function (event) {
                    scrollUpDown(hoverTarget, event.clientY, true);
                });
                document.querySelector(".hoverButtonsBackground .hoverButtonDown").addEventListener("click", function (event) {
                    scrollUpDown(hoverTarget, event.clientY, false);
                });
                document.querySelector(".hoverButtonsBackground .hoverButtonCopy").addEventListener("click", function (event) {
                    let elementInner = hoverTarget.querySelector("pre");
                    /**
                     * Copy Methods comparison:
                     * Copy Method 1: e.clipboardData.setData
                     *      - Chrome & Firefox can't copy newlines
                     * Copy Method 2: navigator.clipboard.writeText
                     *      - Firefox can't copy newlines
                     * Copy Method 3: range and document.execCommand("copy")
                     *      - Chrome can't copy contenteditable nodes
                     *
                     * Solution: use Method 2 on chromium and Method 3 on others (Firefox)
                     *
                     * */
                    //Use innerText as it converts <br>'s that were manually added with Enter into \n's. (not necessary on chrome when using display: inline-block)
                    if (isChromium) {
                        //Copy Method 2
                        navigator.clipboard.writeText(elementInner.innerText).then((result) => {
                            return;
                        });
                    } else {
                        //Copy Method 3
                        elementInner.focus();
                        window.getSelection().removeAllRanges();
                        let range = document.createRange();
                        range.selectNode(elementInner);
                        window.getSelection().addRange(range);
                        document.execCommand("copy");
                        window.getSelection().removeAllRanges();
                    }

                    /*
                //Copy Method 1
                //Add a temporary copy event listener
                function clipListener(e) {
                    e.clipboardData.setData("text/plain", elementInner.innerText);
                    e.preventDefault();
                }
                document.addEventListener("copy", clipListener);
                document.execCommand("copy");
                document.removeEventListener("copy", clipListener);
                */
                });

                //Return the created node
                return document.querySelector(".hoverButtonsBackground");
            }

            //get hoverButtonsBackground (or recreate it)
            function getHoverButtons() {
                return document.querySelector(".hoverButtonsBackground") || createHoverButtons();
            }

            //start undo/redo buttons
            function historyPush(resetforward = true, forward = false) {
                let textlinesNode = document.querySelector("#textlines").cloneNode(true);
                let dummyDiv = document.createElement("div");
                for (const element of textlinesNode.childNodes) {
                    try {
                        //ignore text only nodes (that were just inserted)
                        if (element.firstChild && element.firstChild.nodeName != "#text") {
                            let textPre = element.querySelector("pre");
                            //clean up contenteditable
                            textPre.removeAttribute("contenteditable");
                            //push node with inner pre
                            dummyDiv.append(element.cloneNode(true));
                        }
                    } catch (error) {
                        console.error(error);
                    }
                }
                let historydict = {
                    state: dummyDiv.innerHTML,
                    line_count: dummyDiv.childNodes.length,
                };

                //Forward history (redo button)
                if (forward) {
                    let historylength_forward = historystack_forward.push(historydict);
                    if (historylength_forward > maxhistorylength) {
                        historystack_forward.shift();
                    }

                    //Regular history (undo button)
                } else {
                    let historylength = historystack.push(historydict);
                    if (historylength > maxhistorylength) {
                        historystack.shift();
                    }
                    if (resetforward) {
                        //reset forward history
                        historystack_forward.length = 0;
                    }
                }

                setHistoryButtons();
            }

            function historyPop(forward = false) {
                let popDict;
                //Forward history pop (redo)
                if (forward) {
                    historyPush(false);
                    popDict = historystack_forward.pop();

                    //Regular history pop (undo)
                } else {
                    historyPush(false, true);
                    popDict = historystack.pop();
                }

                forgiveHistoryTimes = popDict.line_count;
                document.querySelector("#textlines").innerHTML = popDict.state;
                //Update the counter (for blank history states)
                updateCounter();

                setHistoryButtons();
            }

            function setHistoryButtons() {
                if (historystack.length >= 1) {
                    document.querySelector("#undo_button").removeAttribute("disabled");
                } else {
                    document.querySelector("#undo_button").setAttribute("disabled", "");
                }
                if (historystack_forward.length >= 1) {
                    document.querySelector("#redo_button").removeAttribute("disabled");
                } else {
                    document.querySelector("#redo_button").setAttribute("disabled", "");
                }
            }
            //end undo/redo buttons

            //toggle background color
            function toggleBackgroundColor() {
                document.body.classList.toggle("bgtoggled");
            }

            //toggle overlay mode
            function toggleOverlayMode() {
                const overlayCounterHTML = `<div id="counter" class="overlaycounter" title="No. of characters / No. of lines
Undo/Redo functionality will be slower the more lines you have.">0 / 0</div>`;

                const overlayButtonsHTML = `<div id="overlay_buttons_container">
    <div id="overlay_down_button" title="Scroll Down
(Don't use this button to scroll between lines. Use the 'Scroll down one line' button instead.)">
        <!-- Hand drawn icon using https://yqnn.github.io/svg-path-editor/ -->
        <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 18">
            <path fill="currentColor" d="M 10 18 L 0 0 L 20 0 L 10 18" />
        </svg>
    </div>
    <div id="overlay_up_button" title="Scroll Up
(Don't use this button to scroll between lines. Use the 'Scroll up one line' button instead.)">
        <!-- Hand drawn icon using https://yqnn.github.io/svg-path-editor/ -->
        <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 18">
            <path fill="currentColor" d="M 10 0 L 0 18 L 20 18 L 10 0" />
        </svg>
    </div>
    <div id="overlay_top_button" title="Scroll to the Top">
        <!-- Hand drawn icon using https://yqnn.github.io/svg-path-editor/ -->
        <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 13 16">
            <path fill="currentColor" d="M 6.5 0 L 0 6 L 0 12 L 4 8 v 8 h 5 V 8 L 13 12 L 13 6 L 6.5 0 z" />
        </svg>
    </div>
    <div id="overlay_bottom_button" title="Scroll to the Bottom">
        <!-- Hand drawn icon using https://yqnn.github.io/svg-path-editor/ -->
        <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 13 16">
            <path fill="currentColor" d="M 6.5 0 L 0 6 L 0 12 L 4 8 v 8 h 5 V 8 L 13 12 L 13 6 L 6.5 0 z" />
        </svg>
    </div>
    <div id="overlay_text_button" title="Toggle Text Visibility
If you hover this button while it is enabled, text lines will be visible until a new line is added." class="">
        <!-- Hand drawn icon using https://yqnn.github.io/svg-path-editor/ -->
        <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 9 11">
            <path fill="currentColor" d="M 4 0 C -1 0 -1 6 4 6 M 4 0 L 9 0 L 9 11 L 7 11 L 7 1 L 6 1 L 6 11 L 4 11 L 4 6" />
        </svg>
    </div>
    <div id="overlay_background_button" title="Toggle Backlog Mode">
        <!-- Fluent UI System Icons, License: MIT, https://github.com/microsoft/fluentui-system-icons -->
        <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
            <path fill="currentColor" d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2S2 6.477 2 12s4.477 10 10 10Zm0-2V4a8 8 0 1 1 0 16Z" />
        </svg>
    </div>
</div>
`;

                let htmlNode = document.documentElement;

                if (htmlNode.classList.contains("overlaymode")) {
                    //turn overlay mode off

                    //If backlog mode is enabled, disable it.
                    if (overlayModeBacklog) {
                        toggleBacklogMode();
                    }
                    //If text visibility button is toggled, disable it.
                    if (document.querySelector("#textlines.hidden")) {
                        toggleTextVisibility("button_click");
                    }

                    document.title = pageTitle = pageTitle.replace(" (Overlay Mode)", "");
                    htmlNode.classList.remove("overlaymode");
                    document.querySelector("#overlaycss").setAttribute("media", "not all");
                    document.querySelector("#overlay_button").classList.remove("button_on");

                    //Remove overlay buttons
                    document.querySelector("#overlay_buttons_container").remove();
                    //Set the regular counter's value and remove overlay counter
                    document.querySelector(".countercontainer #counter").textContent = document.querySelector("#toprightbuttons .overlaycounter").textContent;
                    document.querySelector(".overlaycounter").remove();

                    overlayModeEnabled = false;

                    //Scroll to the top/bottom based on the current setting
                    doScrollOnNewline();
                } else {
                    //Move hover buttons to body
                    document.body.append(getHoverButtons());

                    //turn overlay mode on
                    document.title = pageTitle = pageTitle + " (Overlay Mode)";
                    htmlNode.classList.add("overlaymode");
                    document.querySelector("#overlaycss").setAttribute("media", "all");
                    document.querySelector("#overlay_button").classList.add("button_on");

                    //Add overlay counter and set its value
                    document.querySelector("#toprightbuttons").insertAdjacentHTML("afterbegin", overlayCounterHTML);
                    document.querySelector("#toprightbuttons .overlaycounter").textContent = document.querySelector(".countercontainer #counter").textContent;

                    //Add overlay buttons
                    let newContainerDiv = document.createElement("div");
                    document.body.prepend(newContainerDiv);
                    newContainerDiv.outerHTML = overlayButtonsHTML;
                    //Overlay button events
                    document.getElementById("overlay_down_button").addEventListener("click", function (event) {
                        if (linecount > 0) {
                            let selector = overlayModeBacklog ? window : document.body;
                            selector.scrollBy({ left: 0, top: 108, behavior: "smooth" });
                        }
                    });
                    document.getElementById("overlay_up_button").addEventListener("click", function (event) {
                        if (linecount > 0) {
                            let selector = overlayModeBacklog ? window : document.body;
                            selector.scrollBy({ left: 0, top: -108, behavior: "smooth" });
                        }
                    });

                    //slowly scroll up/down when these buttons are hovered
                    let scrollInterval = null;
                    let scrollTimeout = null;
                    document.getElementById("overlay_down_button").addEventListener("mouseenter", function (event) {
                        if (settings.hoverScrollEnabled && linecount > 0) {
                            scrollTimeout = setTimeout(() => {
                                // scrollInterval = setInterval(() => {
                                //behavior: "smooth" feels worse if we repeat the action
                                document.querySelector("body").scrollBy({ left: 0, top: settings.hoverScrollSpeed, behavior: "smooth" });
                                // }, 10);
                            }, 400);
                        }
                    });

                    document.getElementById("overlay_down_button").addEventListener("mouseleave", function (event) {
                        clearTimeout(scrollTimeout);
                        clearInterval(scrollInterval);
                    });

                    document.getElementById("overlay_up_button").addEventListener("mouseenter", function (event) {
                        if (settings.hoverScrollEnabled && linecount > 0) {
                            scrollTimeout = setTimeout(() => {
                                // scrollInterval = setInterval(() => {
                                document.querySelector("body").scrollBy({ left: 0, top: -settings.hoverScrollSpeed, behavior: "smooth" });
                                // }, 10);
                            }, 400);
                        }
                    });

                    document.getElementById("overlay_up_button").addEventListener("mouseleave", function (event) {
                        clearTimeout(scrollTimeout);
                        clearInterval(scrollInterval);
                    });

                    document.getElementById("overlay_bottom_button").addEventListener("click", function (event) {
                        scrollFirstLast("last");
                    });
                    document.getElementById("overlay_top_button").addEventListener("click", function (event) {
                        scrollFirstLast("first");
                    });
                    document.getElementById("overlay_background_button").addEventListener("click", function (event) {
                        toggleBacklogMode();
                    });
                    document.getElementById("overlay_text_button").addEventListener("click", function (event) {
                        toggleTextVisibility("button_click");
                    });

                    //When hovered, temporarily show text lines until a new line is added (only while the button is turned on)
                    document.getElementById("overlay_text_button").addEventListener("mouseenter", function (event) {
                        if (!textlinesTempVisible && event.target.classList.contains("button_on")) {
                            toggleTextVisibility("temp_show");
                        }
                    });

                    overlayModeEnabled = true;

                    //Scroll to the top/bottom based on the current setting
                    doScrollOnNewline();
                }
            }

            //Overlay Mode: Toggle text visibility
            function toggleTextVisibility(trigger = false) {
                let textbutton = document.getElementById("overlay_text_button");
                let action = "hide";

                switch (trigger) {
                    case "button_click":
                        action = textbutton.classList.contains("button_on") ? "show" : "hide";
                        textbutton.classList.toggle("button_on");
                        //temp visibility is off
                        textlinesTempVisible = false;
                        break;

                    case "temp_show":
                        action = "show";
                        //temp visibility is on
                        textlinesTempVisible = true;
                        break;

                    case "temp_hide":
                        //temp visibility is off
                        textlinesTempVisible = false;
                        break;

                    default:
                        break;
                }

                if (action == "show") {
                    //Unhide text lines
                    document.querySelector("#textlines").classList.remove("hidden");
                    //show hover buttons as well (if there are any lines)
                    if (linecount > 0) {
                        getHoverButtons().classList.remove("hidden");
                    }
                } else {
                    //hide text lines
                    document.querySelector("#textlines").classList.add("hidden");
                    //hide hover buttons as well
                    getHoverButtons().classList.add("hidden");
                }
            }

            //Overlay Mode: Toggle backlog mode
            function toggleBacklogMode() {
                //disable backlog mode
                if (overlayModeBacklog) {
                    overlayModeBacklog = !overlayModeBacklog;

                    //Move hover buttons to body
                    document.body.append(getHoverButtons());

                    document.documentElement.classList.remove("backlogmode");
                    document.querySelector("#overlay_background_button").classList.remove("button_on");

                    //Scroll to the top/bottom based on the current setting
                    doScrollOnNewline();

                    //enable backlog mode
                } else {
                    overlayModeBacklog = !overlayModeBacklog;
                    document.documentElement.classList.add("backlogmode");
                    document.querySelector("#overlay_background_button").classList.add("button_on");

                    //Scroll to the top/bottom based on the current setting
                    doScrollOnNewline();
                }
            }

            //toggle editing
            function toggleEditing(firstload = false, nonewline = false) {
                if (firstload) {
                    //Exists so we can simply use this function without toggling
                    settings.editingEnabled = !settings.editingEnabled;
                }
                if (settings.editingEnabled) {
                    //disable editing, set button style
                    const linesArray = document.querySelectorAll("#textlines>pre>pre").forEach((element) => {
                        element.removeAttribute("contenteditable");
                    });
                    document.querySelector("#edit_button").classList.remove("button_on");
                    //also unpin if we pinned it
                    if (editPinnedButtons) {
                        togglePinning();
                    }
                    settings.editingEnabled = !settings.editingEnabled;
                    saveSettings("editingEnabled");
                } else {
                    //push to history, enable editing, set button style
                    historyPush();
                    const linesArray = document.querySelectorAll("#textlines>pre>pre").forEach((element) => {
                        element.setAttribute("contenteditable", isChromium ? "plaintext-only" : "true");
                    });
                    document.querySelector("#edit_button").classList.add("button_on");
                    //also pin the buttons as well
                    if (!document.querySelector("#pin_button.button_on") && !firstload) {
                        editPinnedButtons = true;
                        togglePinning();
                    }
                    settings.editingEnabled = !settings.editingEnabled;
                    saveSettings("editingEnabled");
                    //If there are no lines, add a new line (and focus it)
                    if (!nonewline && !firstload && linecount == 0) {
                        addNewLine();
                    }
                }
            }

            //Prevents text copied on this page from being inserted into the page.
            //The copy button on every line still works. BUT maybe it shouldnt?
            function toggleCopying(firstload = false) {
                if (firstload) {
                    //Exists so we can simply use this function without toggling
                    settings.copyOnPageEnabled = !settings.copyOnPageEnabled;
                }
                if (settings.copyOnPageEnabled) {
                    //Enable copy and cut
                    document.querySelector("#toggle_copy_button").classList.remove("button_on");
                } else {
                    //Disable copy and cut text from being inserted to the page
                    document.querySelector("#toggle_copy_button").classList.add("button_on");
                }
                settings.copyOnPageEnabled = !settings.copyOnPageEnabled;
                saveSettings("copyOnPageEnabled");
            }

            //add new line
            function addNewLine() {
                if (!settings.editingEnabled) {
                    toggleEditing(false, true);
                }

                newpre = document.createElement("pre");
                newpre.innerHTML = "";
                //append or prepend the new line based on the current setting, prepend is default.
                switch (settings.scrollOnNewline) {
                    case "disabled":
                        document.querySelector("#textlines").prepend(newpre);
                        break;
                    case "toBottom":
                        document.querySelector("#textlines").append(newpre);
                        break;
                    case "toTop":
                        document.querySelector("#textlines").prepend(newpre);
                        break;
                    default:
                        document.querySelector("#textlines").prepend(newpre);
                        break;
                }
                //Workaround for focusing contenteditable (https://stackoverflow.com/a/37162116/5050478)
                setTimeout(function () {
                    newpre.querySelector("pre").focus();
                }, 0);
            }

            //toggle pinning
            function togglePinning(firstload = false) {
                if (firstload) {
                    //Exists so we can simply use this function without toggling
                    settings.pinningEnabled = !settings.pinningEnabled;
                }
                if (settings.pinningEnabled) {
                    document.querySelector("#toprightbuttons").removeAttribute("style");
                    editPinnedButtons = false;
                } else {
                    document.querySelector("#toprightbuttons").setAttribute("style", "display:inline-block;");
                }
                document.querySelector("#pin_button").classList.toggle("button_on");

                //handle menu button visibility (for edge cases)
                handleMenuState();
                settings.pinningEnabled = !settings.pinningEnabled;
                if (!editPinnedButtons) {
                    saveSettings("pinningEnabled");
                }
            }

            //purge extra lines
            function purgeExtraLines() {
                purged_lines.push("////// STARTED PURGING LINES. Time: " + new Date().toString());
                //es6 NodeList to array
                let purgeArray = [...document.querySelectorAll("#textlines > pre")];
                switch (settings.scrollOnNewline) {
                    case "toTop":
                        //bottom 500
                        purgeArray = purgeArray.slice(-500);
                        break;
                    case "disabled":
                    case "toBottom":
                    default:
                        //top 500
                        purgeArray = purgeArray.slice(0, 499);
                        break;
                }
                purgeArray.forEach((element) => {
                    purged_lines.push(element.textContent);
                    element.remove();
                });
                purged_lines.push("////// FINISHED PURGING LINES. Time: " + new Date().toString());
                console.log("🧹 Purged 500 lines. Check purged_lines array. 🧹");
            }

            //notify new lines with a document.title change
            function notifyUsingTitle() {
                //Add notification icon
                document.title = "✔ " + pageTitle;

                //Blink the icon
                setTimeout(() => {
                    document.title = "☑ " + pageTitle;
                }, 800);
                //Go back to the original title
                setTimeout(() => {
                    document.title = pageTitle;
                    //Do not get stuck in between frames
                    if (document.title != pageTitle) {
                        setTimeout(() => {
                            document.title = pageTitle;
                        }, 500);
                    }
                }, 1600);
            }

            //Pick scroll method (body or window depending on the current view)
            function doScroll(valueX, valueY) {
                if (overlayModeEnabled && !overlayModeBacklog) {
                    document.body.scroll({ left: valueX, top: valueY }); //behavior: "smooth"
                } else {
                    window.scroll({ left: valueX, top: valueY });
                }
            }

            //scrolling
            function doScrollOnNewline() {
                switch (settings.scrollOnNewline) {
                    case "disabled":
                        break;
                    case "toBottom":
                        scrollFirstLast("last");
                        break;
                    case "toTop":
                        scrollFirstLast("first");
                        break;
                    default:
                        break;
                }
            }

            function scrollFirstLast(scrollTo) {
                //Cancel if there is no first or last
                if (linecount <= 0) {
                    return;
                }

                let target;
                if (scrollTo == "last") {
                    target = document.querySelector("#textlines > pre:last-of-type");
                } else if (scrollTo == "first") {
                    target = document.querySelector("#textlines > pre:first-of-type");
                }

                //Offset (leave some space on top of the line for mouseover events)
                let offset_Y = overlayModeEnabled ? 0 : -2;
                //Scroll to target
                doScroll(0, findPos(target).top + offset_Y);

                //set overlay mode hover target
                if (overlayModeEnabled && !overlayModeBacklog) {
                    moveHoverButtons(target);
                } else {
                    //[HACK] Prevent a problem where hover buttons target a different line when the page moves by itself.
                    moveHoverButtons(null);
                }
            }

            function scrollTopBottom(toTop) {
                let scrollSelector = overlayModeEnabled ? document.body : document.querySelector("html");
                if (toTop == "top") {
                    scrollSelector.scroll(0, 0);
                    //set overlay mode hover target
                    if (overlayModeEnabled && !overlayModeBacklog) {
                        moveHoverButtons(document.querySelector("#textlines > pre:first-of-type"));
                    }
                } else if (toTop == "bottom") {
                    scrollSelector.scrollIntoView(false);
                    //set overlay mode hover target
                    if (overlayModeEnabled && !overlayModeBacklog) {
                        moveHoverButtons(document.querySelector("#textlines > pre:last-of-type"));
                    }
                }
            }

            /**
             * Scroll to the previous/next line. Requires the current element to be alive.
             */
            function scrollUpDown(elementOuter, clientY, scrollUp) {
                let scrollto = null;
                try {
                    if (scrollUp) {
                        //Scroll to the previous element if it exists, otherwise do nothing.
                        scrollto = elementOuter.previousElementSibling;
                    } else {
                        //Scroll to the next element if it exists, otherwise do nothing.
                        scrollto = elementOuter.nextElementSibling;
                    }
                    if (!scrollto) {
                        //Do nothing.
                        return;
                    } else {
                        //Set new hover target
                        moveHoverButtons(scrollto);

                        let scroll_fix_alignment = -12;
                        //Only for overlay mode
                        if (overlayModeEnabled && !overlayModeBacklog) {
                            clientY = 0;
                            scroll_fix_alignment = 0;
                        }

                        //Scroll to the element using mouse clientY and scroll_fix_alignment
                        doScroll(0, findPos(scrollto).top - clientY - scroll_fix_alignment);
                        //scrollto.scrollIntoView();
                    }
                    return;
                } catch (error) {
                    console.error(error);
                }
            }

            //find an element's position in the whole page
            function findPos(obj) {
                if (!obj) {
                    return;
                }
                let curleft = (curtop = 0);
                if (obj && obj.offsetParent) {
                    do {
                        curleft += obj.offsetLeft;
                        curtop += obj.offsetTop;
                    } while ((obj = obj.offsetParent));
                    return {
                        left: curleft,
                        top: curtop,
                    };
                }
            }

            //Currently this method does not work correctly in overlay mode.
            /* 
        function findPos2(obj) {
            const rect = obj.getBoundingClientRect();
            return {
                left: rect.left + window.scrollX,
                top: rect.top + window.scrollY
            }
        }
        */

            function removeLine(elementOuter) {
                //Move the hover buttons to the next target
                if (elementOuter.nextElementSibling) {
                    moveHoverButtons(elementOuter.nextElementSibling);
                } else {
                    moveHoverButtons(elementOuter.previousElementSibling);
                    //Overlay mode hover buttons consistency: scroll up as well.
                    if (overlayModeEnabled && !overlayModeBacklog) {
                        scrollUpDown(elementOuter, 0, true);
                    }
                }

                elementOuter.remove();
                updateCounter();
            }

            function reduceNewlines(elementOuter, event) {
                let elementInner = elementOuter.querySelector("pre");
                //Use innerText for getting the text as it converts all "<br>"'s that were manually added by the Enter key into "\n"'s.
                let modifystring = elementInner.innerText;
                //Do not modify the text if shift is being held
                if (!event.shiftKey) {
                    //trim newline+spaces at the start (once)
                    modifystring = modifystring.replace(/^[\r\t\f\v 　\u00a0]*\n/, "");
                    //trim spaces+newline at the end (once)
                    modifystring = modifystring.replace(/[\r\t\f\v 　\u00a0]*\n$/, "");
                    //clean spaces
                    modifystring = modifystring.replace(/\n[\r\t\f\v 　\u00a0]*/gm, "\n");
                    //reduce newlines by half (at least 1) (6->3, 5->3, 4->2, 3->2, 2->1, 1->0 etc...)
                    modifystring = modifystring.replace(/(\n(\n+?))|(\n+?)/gm, "$2$3");

                    if (event.altKey) {
                        //completely remove all tabs and spaces etc.
                        modifystring = modifystring.replace(/[\r\t\f\v 　\u00a0]/gm, "");
                    }
                }
                //Use textContent to put the clean string into the div (without <br>'s).
                elementInner.textContent = modifystring;
            }

            //Note: linecount is used for more than just the #counter
            /**
             * updateCounter:
             * 1. Counts lines and updates the counter.
             * 2. Updates "linecount" global variable which is used here and there to detect if there are any existing lines.
             * 3. Overlay mode: Handles hover button visibility whenever a line is added/removed.
             *
             * */
            function updateCounter() {
                let charlength = 0;
                linecount = 0;
                try {
                    let lines = document.querySelectorAll("#textlines > pre > pre");
                    linecount = lines.length;
                    charlength = document.querySelector("#textlines").textContent.length;
                    /*
                //Alternative: add up each line's length (slower or same speed)
                lines.forEach(element => {
                    charlength += element.textContent.length;
                });
                */
                } catch (error) {
                    console.error(error);
                }

                //Show/hide hover buttons on overlay mode
                if (overlayModeEnabled) {
                    switch (linecount) {
                        case 0:
                            //No more lines
                            getHoverButtons().classList.add("hidden");
                            break;

                        case 1:
                            //There are existing lines and textlines aren't hidden
                            if (!document.querySelector("#textlines").classList.contains("hidden")) {
                                getHoverButtons().classList.remove("hidden");
                            }
                            break;

                        default:
                            break;
                    }
                }

                document.querySelector("#counter").textContent = charlength + " / " + linecount;
                return;
            }
        </script>

        <!-- Main css that styles the page -->
        <style id="maincss" type="text/css">
            /* For flashing the selection background when copied/cut */
            body.selectioncopied ::selection {
                background-color: rgb(20, 75, 185);
                color: rgb(253,253,253);
            }

            html {
                overflow-y: scroll;
                /* Thin scrollbar (firefox) */
                scrollbar-width: thin;
                /* Scrollbar colors (new chromium?) */
                scrollbar-color: #7a7a7b #232327;
            }

            /* Chromium compatibility: Thin Scrollbar (similar to Firefox thin) */
            ::-webkit-scrollbar {
                width: 8px;
            }

            /* scrollbar colors (old chromium) */
            ::-webkit-scrollbar-thumb {
                background: #7a7a7b !important;
            }

            ::-webkit-scrollbar-track {
                background: #232327;
            }

            body {
                margin-top: 14px;
                margin-left: 2%;
                margin-right: 2%;
                margin-bottom: 300px;
                background-color: #202020;
                color: #bcbcbc;
                font-size: 21px;
                font-weight: 400;
                /* Global font. */
                font-family: "Noto Sans JP Light", "Noto Sans", "Meiryo", "Arial", "MS Gothic", "sans-serif";
                /*font-family: "IPAGothic", "Sazanami Gothic", "Kochi Gothic", "VL Gothic", "Ume Gothic", "Pro W3", "Hiragino Kaku Gothic Pro", "Osaka Mono", "Osaka", "MS Gothic", "Meiryo", "M+ 1m";*/
            }

            /* css for the "toggle background color" hotkey */
            body.bgtoggled {
                background-color: #000 !important;
            }

            html.overlaymode:not(.backlogmode) > body.bgtoggled {
                height: 265px;
            }

            html.backlogmode > body.bgtoggled #textlines > pre {
                width: auto;
            }

            /* Main text style */
            pre {
                font-family: inherit;
                white-space: pre-wrap;
                word-wrap: break-word;
                margin: 0;
                padding-bottom: 0px;
                /* Prevent contenteditable outline from covering the caret */
                outline-offset: 2px;
            }

            #textlines > pre {
                border-bottom: #595959 solid 1px;
                padding-bottom: 29px;
                padding-top: 22px;
                margin-top: -12px;
            }

            #textlines > pre > pre {
                /* inline-block: Prevent chrome from adding <div><br></div> when Enter is pressed.*/
                display: inline-block;
                width: 100%;
            }

            /* Preemptively hide compatibility lines to prevent flashing */
            body > p {
                display: none;
            }

            /* Top right buttons & counter css */
            .countercontainer {
                bottom: 1px;
                right: 1px;
                position: fixed;
                display: inline-block;
                user-select: none;
            }

            #counter {
                font-size: 11px;
                padding: 4px 6px 4px 6px;
                margin-right: 0px;
                border-radius: 4px;
                background-color: rgba(25, 25, 25, 0.65);
                color: #9d9d9d;
                line-height: 100%;
                float: left;
                font-family: "Calibri", "Arial";
            }

            #toprightbuttons {
                z-index: 1;
                display: none;
            }

            #toprightbuttons:hover,
            #menucontainer:hover ~ #toprightbuttons {
                display: inline-block;
            }

            .buttoncontainer {
                right: 1px;
                top: 1px;
                position: fixed;
                display: inline-block;
                user-select: none;
                z-index: 1;
            }

            .buttoncontainer svg {
                width: 12px;
                height: 12px;
            }

            .buttoncontainer > div {
                border-radius: 4px;
                margin-right: 5px;
                padding: 2px 4px 0px 4px;
                font-size: 12px;
                color: #9d9d9d;
                fill: #9d9d9d;
                cursor: pointer;
                float: left;
                background-color: rgba(25, 25, 25, 0.65);
            }

            .buttoncontainer > div:hover {
                color: #d7d7d7;
                fill: #d7d7d7;
                background-color: rgba(27, 27, 27, 1);
            }

            .buttoncontainer > #clear_button:hover > svg,
            .buttoncontainer > #add_line_button:hover > svg,
            .buttoncontainer > #remove_button:hover > svg {
                stroke: #d7d7d7;
            }

            #pin_button:not(.button_on) {
                padding: 2px 5px 0px 3px;
            }

            #pin_button_inner {
                transform: rotate(45deg);
            }

            #pin_button.button_on > #pin_button_inner {
                transform: translate(0px, 0px);
            }

            #clear_button > svg {
                stroke: #9d9d9d;
                stroke-width: 0.5px;
                stroke-linecap: round;
            }

            .buttoncontainer > #overlay_button.button_on,
            .buttoncontainer > #edit_button.button_on,
            .buttoncontainer > #toggle_copy_button.button_on {
                box-shadow: inset 0px 0px 3px 2px rgb(69, 183, 44, 0.5);
                color: rgb(51, 144, 31);
                fill: rgb(51, 144, 31);
            }

            #scroll_button.to_top > .arrow_updown,
            #scroll_button.to_bottom > .arrow_updown,
            #scroll_button.no_scroll > .arrow_bidrectional {
                display: block;
            }

            #scroll_button.to_top > .arrow_bidrectional,
            #scroll_button.to_bottom > .arrow_bidrectional,
            #scroll_button.no_scroll > .arrow_updown {
                display: none;
            }

            #scroll_button.to_bottom > .arrow_updown {
                transform: rotate(180deg) translate(0px, 2px);
            }

            #scroll_button.no_scroll:not(:hover) > .arrow_bidrectional {
                color: #555555;
            }

            #add_line_button svg {
                stroke: #9d9d9d;
                /* transform: translate(0px, -7px); */
            }

            #toggle_copy_button svg {
                stroke-width: 0.4px;
                stroke: #9d9d9d;
                stroke-linecap: round;
            }

            .undoredoButtons svg {
                height: 10px;
                width: 10px;
            }

            .undoredoButtons[disabled] {
                pointer-events: none;
                color: #4e4e4e;
            }

            #undo_button {
                margin-right: 0px;
                padding: 1px 3px 1px 6px;
                border-radius: 4px 0px 0px 4px;
            }

            #redo_button {
                border-radius: 0px 4px 4px 0px;
                padding: 1px 6px 1px 3px;
            }

            #remove_button {
                margin-right: 0px;
            }

            #remove_button > svg {
                stroke: #919191;
                stroke-width: 1.5px;
            }

            /* Not a real clickable button */
            #menu_button {
                margin-right: 0px;
            }

            /* Top/Bottom buttons */
            #go_to_last_button {
                margin-left: 120px;
                bottom: -20px;
                position: relative;
                cursor: pointer;
                user-select: none;
                font-size: 22px;
                width: 24px;
                filter: opacity(20%);
            }

            #go_to_last_button:hover {
                filter: opacity(40%);
            }

            #go_bottom_button {
                margin-left: 120px;
                top: -7px !important;
                position: absolute;
                cursor: pointer;
                user-select: none;
                font-size: 22px;
                width: 24px;
                filter: opacity(20%);
            }

            #go_bottom_button:hover {
                filter: opacity(40%);
            }

            /* Hover buttons */
            .hoverButtonsBackground:hover > .hoverButtons {
                opacity: 90%;
            }

            .hoverButtonsBackground.hidden {
                visibility: hidden;
            }

            .hoverButtonsBackground {
                height: 15px;
                padding: 3px 4px 6px 10px;
                border-radius: 6px;
                position: absolute;
                display: flex;
                flex-direction: row;
                justify-content: space-evenly;
                background-color: #1c1c1c;
                z-index: 2;
                font-size: 14px;
                user-select: none;
            }

            .hoverButtons {
                cursor: pointer;
                margin-right: 0px;
                color: #adadad;
                opacity: 40%;
            }

            .hoverButtons:hover {
                filter: brightness(1.5) !important;
            }

            .hoverButtonDelete svg {
                stroke: #adadad;
                stroke-width: 2.8px !important;
                stroke-linecap: round;
                width: 21px;
                margin: -3px 0px 0 -8px;
            }

            .hoverButtonReduceNewlines svg {
                stroke: #adadad;
                stroke-width: 2px;
                margin: -1px 0px 0px -3px;
                padding-top: 1px;
                width: 24px;
                transform: scale(0.7, 1);
                filter: drop-shadow(0px 0px 1px #9999993d);
                stroke-linecap: round;
            }

            .hoverButtonCopy svg {
                stroke: #adadad;
                stroke-width: 2.5px;
                width: 18px;
                margin: -3px 0 0 -1px;
                stroke-linecap: square;
                transform: scale(0.99, 0.92);
            }

            .hoverButtonDown svg,
            .hoverButtonUp svg {
                stroke: #a2a2a2;
                stroke-width: 4px;
                width: 17px;
                stroke-linejoin: round;
                stroke-linecap: round;
                margin: -3px -2px 0px 0px;
            }

            .hoverButtonDown svg {
                margin: -3px 0 0 1px;
                transform: rotate(180deg);
            }

            /* Settings menu styling */
            #settingsBackground {
                position: fixed;
                width: 200vw;
                height: 200vh;
                top: -100%;
                left: -100%;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 3;
                cursor: pointer;
            }

            #settingsWindow {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translateX(calc(-50% - 0.5px)) translateY(calc(-50% - 0.5px));
                color: #ccc;
                box-shadow: 0 2px 4px rgb(0 0 0 / 25%), 0 2px 4px rgb(0 0 0 / 35%);
                background-color: rgb(30, 30, 30);
                border: 2px rgb(30, 30, 30) solid;
                display: block;
                width: 70%;
                max-width: 500px;
                max-height: 80%;
                overflow: auto;
                /* height: 50%; */
                border-radius: 15px;
                z-index: 4;
                font-size: 12pt;
                font-family: Arial;
                line-height: 1.5em;
                padding: 0% 2% 2% 2%;
            }

            #settingsWindow input[type="checkbox"] {
                margin-left: 0px;
            }

            #settingsContainer input[type="number"],
            #settingsContainer input[type="text"] {
                border-radius: 4px;
                color: #b9b9b9;
                padding: 2px 3px;
                background: #222;
                border: 1px solid #555;
            }

            #settingsContainer button {
                filter: brightness(0.95) contrast(0.95);
                font-weight: bold;
                font-size: 11pt;
                margin-inline: auto;
                display: block;
                padding: 4px 10px;
                margin: 0 auto 0px auto;
            }

            #settingsContainer .settingTooltip {
                background: #113678;
                color: #e7e7e7;
                font-weight: bold;
                font-size: 11pt;
                padding: 2px 5px 1px 5px;
                border-radius: 6px;
                margin-left: 5px;
                cursor: help;
                vertical-align: -1px;
                line-height: 1px;
            }

            #settingsContainer .settingCloseButton {
                position: absolute;
                right: 6px;
                top: 6px;
                border-radius: 10px;
                background: #353535;
                padding: 1px 0px 0px 1px;
                cursor: pointer;
                width: 31px;
                height: 31px;

                &:hover {
                    background: #444;
                }
            }
        </style>

        <!-- This style is only for the overlay mode. Disabled by default (media="not all") -->
        <style id="overlaycss" type="text/css" media="not all">
            html.overlaymode > body {
                background-color: #000;
                margin-bottom: -31px;
                margin-top: 0px;
                overflow: auto;
                height: 134px;
            }

            /* Hide scrollbar (except for .backlogmode) */
            html.overlaymode,
            html.overlaymode > body {
                /* Firefox */
                scrollbar-width: none;
            }

            html.overlaymode:not(.backlogmode) > body::-webkit-scrollbar {
                /* Chromium */
                width: 0 !important;
            }

            html.overlaymode.backlogmode {
                scrollbar-width: thin;
            }

            /* Prevent reflow caused by the backlog's scrollbar (both browsers) */
            html.overlaymode.backlogmode #overlay_buttons_container {
                left: calc(30% + 2.4px); /* 30% of 8px */
            }

            html.overlaymode:not(.backlogmode) {
                margin-right: 8px;
            }

            html.overlaymode.backlogmode > body {
                background-color: #202020;
                height: 100%;
            }

            html.overlaymode.backlogmode > body > #textlines {
                margin-top: 12px;
            }

            html.overlaymode.backlogmode > body > #textlines > pre > pre {
                color: #e3e3e3;
            }

            html.overlaymode:not(.backlogmode) #textlines.hidden {
                visibility: hidden;
            }

            html.overlaymode #textlines > pre {
                margin-left: auto;
                margin-right: auto;
                width: 56%;
            }

            html.overlaymode:not(.backlogmode) > body #textlines > pre {
                padding-bottom: 134px;
                margin-top: 0px;
                border-width: 2px;
                border-color: #2f2f2f;
            }

            html.overlaymode #textlines > pre > pre {
                font-size: 24px;
                line-height: 1.125em;
                /* text-shadow: -1px -1px 0 #101010, 0 -1px 0 #101010, 1px -1px 0 #101010, 1px 0 0 #101010, 1px 1px 0 #101010, 0 1px 0 #101010, -1px 1px 0 #101010, -1px 0 0 #101010; */

                /* ---Old MS Gothic style--- */
                /* color: #fcfcfc; */
                /* text-shadow: 0px 0px 2px #0b0b0b; */
                /* font-family: "MS Gothic", "Noto Sans JP Medium", "Meiryo"; */
                /* -webkit-text-stroke: .2px #eee; */

                /* ---New Noto Sans JP Medium style--- */
                color: #f4f4f4;
                text-shadow: 0px 0px 1.7px #0b0b0b;
                font-family: "Noto Sans JP", "Noto Sans", "Meiryo", "Arial", "MS Gothic", "sans-serif";
            }

            html.overlaymode #go_to_last_button,
            html.overlaymode #go_bottom_button {
                display: none;
            }

            html.overlaymode #toprightbuttons {
                background-color: #50505099;
                border-radius: 4px;
                top: 0px;
            }

            html.overlaymode #counter.overlaycounter {
                padding: 5px 6px 4px 6px;
                margin-right: 6px;
                cursor: auto;
            }

            html.overlaymode #menucontainer {
                opacity: 0.5;
            }

            html.overlaymode #menu_button {
                padding: 2px;
                line-height: 1px;
            }

            html.overlaymode #menu_button > svg {
                width: 9px;
                height: 9px;
            }

            html.overlaymode .countercontainer {
                display: none;
            }

            /* overmay mode hover buttons */
            html.overlaymode .hoverButtonsBackground {
                left: 23% !important;
            }

            html.overlaymode:not(.backlogmode) body .hoverButtonsBackground {
                position: fixed;
                transform: scale(1, 0.1) translate(0px, -108px);
                padding-bottom: 4px;
                top: 0px !important;
            }

            html.overlaymode:not(.backlogmode) body .hoverButtonsBackground:hover {
                transform: scale(1, 1) translate(0px, -1px);
                padding: 2px 5px 6px 11px;
            }

            html.overlaymode:not(.backlogmode) body .hoverButtonsBackground > .hoverButtons {
                filter: brightness(1.3) blur(1px);
            }

            html.overlaymode:not(.backlogmode) body .hoverButtonsBackground:hover > .hoverButtons {
                filter: none;
            }

            html.overlaymode:not(.backlogmode) body #overlay_buttons_container:not(:hover) #overlay_bottom_button {
                margin-top: -5px;
            }

            /* Style overlay buttons */
            #overlay_buttons_container {
                font-size: 21px;
                position: fixed;
                display: flex;
                top: 0px;
                left: 30%;
                height: 28px;
                padding: 0px 10px 1px 10px;
                background-color: #1d1d1d;
                color: #fff;
                /* related to hover functionality */
                transform: scale(1, 0.08) translate(0px, -180px);
                border-radius: none;
                opacity: 0.7;
            }

            #overlay_buttons_container:hover {
                transform: scale(1, 1) translate(0px, -8px);
                border-radius: 6px;
                opacity: 1;
            }

            #overlay_buttons_container > div {
                opacity: 40%;
                cursor: pointer;
                user-select: none;
            }

            #overlay_buttons_container > div:hover {
                opacity: 80%;
            }

            #overlay_buttons_container > div.button_on {
                color: #a6f57ed6;
                opacity: 90%;
            }

            #overlay_buttons_container svg {
                width: 17px;
                height: 17px;
            }

            #overlay_down_button {
                margin: 1px 8px 0px 0px;
            }

            #overlay_up_button {
                margin: 1px 24px 0px 0px;
            }

            #overlay_bottom_button {
                margin: 0px 20px -4px 7px;
                transform: rotate(180deg);
            }

            #overlay_text_button {
                margin: 0px 1px 0px 0px;
                /* Add inline paddings to make the hover size larger */
                padding: 0px 2px 0px 4px;
            }

            #overlay_buttons_container #overlay_text_button > svg {
                width: 15px;
                height: 15px;
            }

            #overlay_background_button {
                margin-left: 3px;
            }

            #overlay_buttons_container #overlay_background_button > svg {
                width: 19px;
                height: 19px;
                margin-top: 7px;
            }
        </style>
    </head>

    <body>
        <div id="go_bottom_button" title="Scroll to the bottom">🡻</div>
        <div id="menucontainer" class="buttoncontainer">
            <div id="menu_button" onclick="togglePinning();" title="Menu">
                <!-- Font Awesome Icons, License: CC BY 4.0, https://fontawesome.com/license/free -->
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
                    <path fill="currentColor" d="m487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14c-11.1-35.6-30-67.8-54.7-94.6c-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7c-36.7-8.2-74.3-7.8-109.2 0c-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3c-24.7 26.7-43.6 58.9-54.7 94.6c-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14c11.1 35.6 30 67.8 54.7 94.6c3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7c36.7 8.2 74.3 7.8 109.2 0c5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3c24.7-26.7 43.6-58.9 54.7-94.6c1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80s80 35.9 80 80s-35.9 80-80 80z" />
                </svg>
            </div>
        </div>
        <div id="toprightbuttons" class="buttoncontainer">
            <div
                id="overlay_button"
                onclick="toggleOverlayMode();"
                title="Toggle Overlay Mode
Requires external help (e.g. ahk script) to function correctly."
            >
                <!-- Bootstrap Icons, License: MIT, https://github.com/twbs/icons -->
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16">
                    <g fill="currentColor">
                        <path d="M9.167 4.5a1.167 1.167 0 1 1-2.334 0a1.167 1.167 0 0 1 2.334 0Z" />
                        <path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0ZM1 8a7 7 0 0 1 7-7a3.5 3.5 0 1 1 0 7a3.5 3.5 0 1 0 0 7a7 7 0 0 1-7-7Zm7 4.667a1.167 1.167 0 1 1 0-2.334a1.167 1.167 0 0 1 0 2.334Z" />
                    </g>
                </svg>
            </div>

            <div id="pin_button" onclick="togglePinning();" title="Pin/Unpin the menu">
                <div id="pin_button_inner">
                    <!-- Google Material Icons, License: Apache 2.0, https://github.com/material-icons/material-icons -->
                    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24">
                        <path fill="currentColor" fill-rule="evenodd" d="M16 9V4h1c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 1.66-1.34 3-3 3v2h5.97v7l1 1l1-1v-7H19v-2c-1.66 0-3-1.34-3-3z" />
                    </svg>
                </div>
            </div>
            <div
                id="clear_button"
                title="Clear all lines.
(Shift+Click: clear all history as well)"
            >
                <!-- Codicon, License: CC BY 4.0, https://github.com/microsoft/vscode-codicons -->
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16">
                    <path fill="currentColor" d="M8 1a7 7 0 1 1-7 7a7.008 7.008 0 0 1 7-7zM2 8c0 1.418.504 2.79 1.423 3.87l8.447-8.447A5.993 5.993 0 0 0 2 8zm12 0c0-1.418-.504-2.79-1.423-3.87L4.13 12.577A5.993 5.993 0 0 0 14 8z" />
                </svg>
            </div>
            <div
                id="scroll_button"
                title="Scroll to bottom(↓)/top(↑)/disabled(↕) when a new line is added.
Also prepends new lines by default if set to top(↑)."
            >
                <!-- Fluent UI System Icons, License: MIT, https://github.com/microsoft/fluentui-system-icons -->
                <div class="arrow_updown">
                    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 12 12">
                        <path fill="currentColor" d="M6 10.5a.75.75 0 0 0 .75-.75V3.81l1.97 1.97a.75.75 0 0 0 1.06-1.06L6.53 1.47a.75.75 0 0 0-1.06 0L2.22 4.72a.75.75 0 1 0 1.06 1.06l1.97-1.97v5.94c0 .414.336.75.75.75Z" />
                    </svg>
                </div>
                <div class="arrow_bidrectional">
                    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 12 12">
                        <path fill="currentColor" d="M3.78 4.53a.75.75 0 0 1-1.06-1.06l2.5-2.5a.75.75 0 0 1 1.06 0l2.5 2.5a.75.75 0 0 1-1.06 1.06L6.5 3.31v5.38l1.22-1.22a.75.75 0 0 1 1.06 1.06l-2.5 2.5a.75.75 0 0 1-1.06 0l-2.5-2.5a.75.75 0 0 1 1.06-1.06L5 8.69V3.31L3.78 4.53Z" />
                    </svg>
                </div>
            </div>
            <div
                id="toggle_copy_button"
                onclick="toggleCopying();"
                title="When turned on (i.e. button has green border), text copied on this page will be inserted just like any other clipboard text.,
When turned off (i.e. button is regular), text copied on this page will be ignored and not inserted as a new line.
The copy buttons on each line will always insert a new line."
            >
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16">
                    <g fill="currentColor">
                        <path d="M3.5 2a.5.5 0 0 0-.5.5v12a.5.5 0 0 0 .5.5h9a.5.5 0 0 0 .5-.5v-12a.5.5 0 0 0-.5-.5H12a.5.5 0 0 1 0-1h.5A1.5 1.5 0 0 1 14 2.5v12a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 14.5v-12A1.5 1.5 0 0 1 3.5 1H4a.5.5 0 0 1 0 1h-.5Z" />
                        <path d="M10 .5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5a.5.5 0 0 1-.5.5a.5.5 0 0 0-.5.5V2a.5.5 0 0 0 .5.5h5A.5.5 0 0 0 11 2v-.5a.5.5 0 0 0-.5-.5a.5.5 0 0 1-.5-.5Z" />
                    </g>
                </svg>
            </div>
            <div
                id="edit_button"
                onclick="toggleEditing();"
                title="Toggles editable lines.
History is saved right when you enable this,
so disable it if you want when you are done.
Toggle Shortcut: Alt + S"
            >
                <!-- Bootstrap Icons, License: MIT, https://github.com/twbs/icons -->
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16">
                    <path fill="currentColor" d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5L13.5 4.793L14.793 3.5L12.5 1.207L11.207 2.5zm1.586 3L10.5 3.207L4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175l-.106.106l-1.528 3.821l3.821-1.528l.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z" />
                </svg>
            </div>
            <div
                id="add_line_button"
                onclick="addNewLine();"
                title="Adds a new line and enables editing.
Saves history when pressed."
            >
                <!-- Octicons, License: MIT, https://github.com/primer/octicons/ -->
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16">
                    <path fill="currentColor" fill-rule="evenodd" d="M8 2a.75.75 0 01.75.75v4.5h4.5a.75.75 0 010 1.5h-4.5v4.5a.75.75 0 01-1.5 0v-4.5h-4.5a.75.75 0 010-1.5h4.5v-4.5A.75.75 0 018 2z" />
                </svg>
            </div>
            <div id="undo_button" onclick="historyPop();" class="undoredoButtons" disabled="" title="Undo">
                <!-- Font Awesome Icons, License: CC BY 4.0, https://fontawesome.com/license/free -->
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z"></path>
                </svg>
            </div>
            <div id="redo_button" onclick="historyPop(true);" class="undoredoButtons" disabled="" title="Redo">
                <!-- Font Awesome Icons, License: CC BY 4.0, https://fontawesome.com/license/free -->
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z"></path>
                </svg>
            </div>
            <div id="settings_button" onclick="openSettingsMenu();" title="Open settings menu">
                <!-- Fluent UI System Icons, License: MIT, https://github.com/microsoft/fluentui-system-icons -->
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16">
                    <path fill="currentColor" d="M11 1a4 4 0 0 0-3.896 4.91l-5.051 5.235a1.986 1.986 0 0 0 2.842 2.774l5.007-5.072a4.002 4.002 0 0 0 5.062-4.382a.5.5 0 0 0-.85-.287L12 6.293L9.707 4l2.115-2.115a.5.5 0 0 0-.287-.85A4.032 4.032 0 0 0 10.999 1Z" />
                </svg>
            </div>
            <div
                id="remove_button"
                title="Remove first/last line
Removes the first line when auto scroll is set to 'Scroll to top(↑)'"
            >
                <!-- Octicons, License: MIT, https://github.com/primer/octicons/ -->
                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16">
                    <path fill="currentColor" fill-rule="evenodd" d="M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.75.75 0 1 1 1.06 1.06L9.06 8l3.22 3.22a.75.75 0 1 1-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 0 1-1.06-1.06L6.94 8L3.72 4.78a.75.75 0 0 1 0-1.06z" />
                </svg>
            </div>
        </div>
        <div class="countercontainer">
            <div
                id="counter"
                title="No. of characters / No. of lines
Undo/Redo functionality will be slower the more lines you have."
            >
                0 / 0
            </div>
        </div>
        <div style="display: none">
            <!-- Dummy div for buttons-->
        </div>

        <!-- inserted pre tags go inside #textlines -->
        <div id="textlines"></div>

        <div id="go_to_last_button" title="Scroll to the start of the last item">🡹</div>
    </body>
</html>
