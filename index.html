<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <!-- Title -->
    <title>Clipboard Inserter HTML Enhanced</title>
    <!-- Scary base64 encoded favicon (小) -->
    <link href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAK9WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDUgNzkuMTY0NTkwLCAyMDIwLzEyLzA5LTExOjU3OjQ0ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjIuMSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIxLTAzLTE1VDAzOjQyOjMzKzAzOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIxLTAzLTE1VDA0OjAxOjI1KzAzOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMS0wMy0xNVQwNDowMToyNSswMzowMCIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Y2VhOTk4YmYtZGI0Ny0zZTQ2LWFiMzctYzBjYjU4ZWM3NGVjIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6NzlmNzhhZmEtOThiYi0xZDRiLWE0MGQtNTFjNmNhMWRjN2I0IiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NjBlYjE5MGUtNjJmMy01MTRhLTgyMDYtNDNkMjU5ZTBiNGMwIiB0aWZmOk9yaWVudGF0aW9uPSIxIiB0aWZmOlhSZXNvbHV0aW9uPSI3MjAwMDAvMTAwMDAiIHRpZmY6WVJlc29sdXRpb249IjcyMDAwMC8xMDAwMCIgdGlmZjpSZXNvbHV0aW9uVW5pdD0iMiIgZXhpZjpDb2xvclNwYWNlPSI2NTUzNSIgZXhpZjpQaXhlbFhEaW1lbnNpb249IjI1NiIgZXhpZjpQaXhlbFlEaW1lbnNpb249IjI1NiI+IDxwaG90b3Nob3A6VGV4dExheWVycz4gPHJkZjpCYWc+IDxyZGY6bGkgcGhvdG9zaG9wOkxheWVyTmFtZT0i5bCPIiBwaG90b3Nob3A6TGF5ZXJUZXh0PSLlsI8iLz4gPC9yZGY6QmFnPiA8L3Bob3Rvc2hvcDpUZXh0TGF5ZXJzPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjYwZWIxOTBlLTYyZjMtNTE0YS04MjA2LTQzZDI1OWUwYjRjMCIgc3RFdnQ6d2hlbj0iMjAyMS0wMy0xNVQwMzo0MjozMyswMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1OGZhMGFlOC1mNjg3LTJmNGMtOGVmOS1lZWIxMzU0MTQ0OGMiIHN0RXZ0OndoZW49IjIwMjEtMDMtMTVUMDM6NTA6NTIrMDM6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMi4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MWY5YTE4NDQtYzViZC00MDRlLWE4MjktZDA1MzZmMmExZjllIiBzdEV2dDp3aGVuPSIyMDIxLTAzLTE1VDA0OjAxOjI1KzAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjIuMSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNvbnZlcnRlZCIgc3RFdnQ6cGFyYW1ldGVycz0iZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmNlYTk5OGJmLWRiNDctM2U0Ni1hYjM3LWMwY2I1OGVjNzRlYyIgc3RFdnQ6d2hlbj0iMjAyMS0wMy0xNVQwNDowMToyNSswMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIyLjEgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxZjlhMTg0NC1jNWJkLTQwNGUtYTgyOS1kMDUzNmYyYTFmOWUiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozOGM3NzQ2Ny1hMDZlLTRlNGYtYTdmZC1hM2NkMzNlMWNjY2IiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2MGViMTkwZS02MmYzLTUxNGEtODIwNi00M2QyNTllMGI0YzAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4T8iuIAAAEf0lEQVRIx42WS1DTVxTG0ybhHd6EhLwghCS0U1H6oPShdqZSFaaCba0dRpjWUUdk1JmKnVrRoo0gCvJSwFbbqdNMS0csShACMQnBosUZFl246IKFCxYssmTh4t/vS29mIiSWxW8g957cc853zj03MuvpYVks1N8/igN6sAnsBSfASXAIVIIikAJksZD9j4MkUAoO5J+fuIk1L7GcGZk0XXD3Y30zyFqTg9LS0lXAIA18AM7zYKPRKGVlZUnmdWXL9qbrs3l99/dhzwDk4AWy4vuyyGjlQhJGrRIYQS24RgcZGRmSQqGQdK9vCZodrgkh1TqRRYaQi2e8+IwDcTg3deIL7wjdt4Im8HukA8MbFUHzOdcU1h3gU7BF2L8CtCBxpYNwMTeCL7RXZr/D31OioD3AtdrBmJeZgdbcgYfndN3TF/H/5yI4DVBEOqAcr4EGfZfvBvXlgZRB3+0fwfpUFAc+bf/snfx297jthDPw0qFL82iEYdgeFI2hCjmgXiAX1IAupO4xv7UtmJOTI+WXbw2+vL/1b11PwB/Fgd90YdJbvOPAE7VaLWk0Gsl2jIWfYVa7RPEVdKAENtAIhnhQZmamJJfLpezsbImfsT4TzQGy89vqmh+npKRI8fHxUsH7ny0iCzfsvwFlzCIsD3VzwLvHdrBznl9QKpWS8d3qpYK2cR/2AtEkwrrXcva2T2tbv0x77v+Xxf2fRRY6mag6P1wzXZwKmCv3PmE0SUlJUtHupn8Ml7weHhSjyKOGzns+657mx7SPyGISe1+BDTLRWl+CEUTj11hLlnlIenp6KBpN/wMWeSJKm97D+i+5g3/dYZFzDOan3AtngQYYxH6VTPRwh65n2kt5VCpVSJ6IXv+JkUZxwMwugx9RbF8484SEBMlS07gANUaxt58OPgFXqamhrCIYFxcnJScnS1YUD/IMsbPArRgXrY1oL//psh25MpeamhraZ00sZ24zw+N0UKvrDTgZfdhAjXSLWv6gQQv49jk3uRkcBddZbMrL7uM5dIimaaODnQVtd28Wb69f5CCj9iyuqd39m2jdkzEyYCGPi1nVApnclInFTktLk+wfH15AsQfp4G3ofwrtOEyv9u11i/j/Vu7VuRYxh/qAJ4YDRl8B6nAZf7A3dM4bLMVPCytqF4uP9s/h3MN0YAbvgT0wOm1uHbsByThfzmKtlwUGj1Y5cLh4oRrEWCjTDDzYx24iBa1jTn339DGsl8vEFNWK28x5VKkZeHiEhiiUJ/zIWL92BsIXUDgYh209KBTfL8GQ3Ia2rhYBrwd5K9+CdF4OthdfLcuG8mWOC0bOwxl96DJtqllC1/F+fCjmWIKYCHwX1CBTfI5/5kXjgsik3tgxNcRih6Nm+yYmJkocgnZ0nL7L3w67N3lQtNdw1YsmFpRiClahxTpYKE5WSmLaWL1k2dm4YEcjoAmcsNkB8hnUmhxESEWZSsBuXLS+QseoC3rfRfFdaMVf83pn2F1VItNUMe7X/qtC1IJa2sWvho9Er+8ST+irIktV+NV6Hv8CoQSxebdkGb0AAAAASUVORK5CYII=" rel="icon" type="image/png" />
    <script>
        /*
        /////////////////////////////////////////////////////////////////////////
        ////////// Downloadable HTML for Clipboard Inserter (Enhanced) //////////
        //////////                    Version: 3.0                     //////////
        /////////////////////////////////////////////////////////////////////////


            ------ General Info ------

        ❗ The following Non-default Clipboard Inserter settings are NOT required but highly suggested:
        - element name: pre
        - container selector: #textlines

        You can switch to prepending mode by setting the "Scroll" button to top (Up arrow: ⇑)
        (Or you can just use a modified Clipboard Inserter addon)

        Hover the buttons to read their descriptions.
        Both appending and prepending should work for all buttons and functionality. (Even if you don't have a modified Clipboard Inserter)

        Keyboard shortcuts:
        - Alt + S: Toggle Editing
        - Some more shortcuts among the hidden features below.

        ❗ Default Options and Hidden features:
        - ❗ You can change a few options below.  
        - ❗ You will also find directions to enable some hidden features. These features must be enabled manually if you need them.  
        - ❗ If you are using private browsing mode (or clearing history/cache/localstorage etc.), your settings (button states and hidden options) might not get saved. Just edit the javascript variables directly.

        This page was made piece by piece for personal usage. 
        Therefore; it might not work perfectly on different screen sizes and zoom settings.

        Original page was inspired/borrowed from: https://pastebin.com/raw/HxjV6YrB (Only a few lines of the code left) 
        Which was found here: https://pastebin.com/gNJfqpmN


        TODO: nothing

        NEVER: (useless for now) Maybe add a name detection system: (sounds useless)
            ^^^ if clipboard text starts with "CI=Name" or something: put it in front of the previous text. If name gets copied first it could be weird.
            ^^^ maybe try using global variables on Textractor lua

        */

        //------ Default Options ------
        //Read below for more info.
        const settings = {
            scrollOnNewline: "toBottom",
            notifyOnNewline: false,
            overlayHotkeyEnabled: false,
            backlogHotkeyEnabled: false,
            pinningEnabled: false,
            editingEnabled: false,
            autoHideYomichan: true,
            purge500LinesWhen: 0,
        }
        //------ Hidden Features ------
        /**
         * autoHideYomichan
         * 
         * true: Allows you to auto-hide the yomichan popup when your mouse is out of the window, 
         * false: disabled
         * ❗ This option requires the setting "Use a secure container around popups" to be off in yomichan's options.
         * 
         * Console command to permanently disable this without editing the values above:
         * localStorage.setItem("autoHideYomichan", false);
         * 
         * */
        /**
         * purge500LinesWhen
         * 
         * Purges the oldest 500 lines when you go over this amount (which can keep the page smooth).
         * 
         * 0: disabled
         * Any number other than 0: enabled
         * 
         * To enable this for 1500 lines, enter the following line into your console on this page and refresh:
         * localStorage.setItem("purge500LinesWhen", 1500);
         * 
         * You only have to enter this once unless you clear your browser cache/history/etc. or are using private browsing.
         * 
         * To disable, type this into your console: 
         * localStorage.setItem("purge500LinesWhen", 0);
         * 
         * */
        /**
         * notifyOnNewline
         * 
         * Whenever a new line is added, The symbol ✔ will flash on page's and window's title for a short time
         * 
         * To enable this, enter the following line into your console on this page and refresh:
         * localStorage.setItem("notifyOnNewline", true);
         * 
         * You only have to enter this once unless you clear your browser cache/history/etc. or are using private browsing.
         * 
         * To disable, type this into your console: 
         * localStorage.setItem("notifyOnNewline", false);
         * 
         * */
        /**
         * overlayHotkeyEnabled
         * 
         * Enables the "Toggle overlay mode" Hotkey "Alt + 0" or "}"
         * 
         * This setting just adds a hotkey for the overlay mode feature. You can still use the toggle overlay mode button without enabling this hotkey.
         * 
         * To enable this, enter the following line into your console on this page and refresh:
         * localStorage.setItem("overlayHotkeyEnabled", true);
         * 
         * You only have to enter this once unless you clear your browser cache/history/etc. or are using private browsing.
         * 
         * To disable, type this into your console: 
         * localStorage.setItem("overlayHotkeyEnabled", false);
         * 
         * */

        /**
         * backlogHotkeyEnabled (For Overlay mode)
         * 
         * Enables the "Toggle backlog mode" Hotkey "Alt + O" 
         * 
         * This setting just adds a hotkey for the backlog mode feature. You can still use the backlog mode button without enabling this hotkey.
         * 
         * To enable this, enter the following line into your console on this page and refresh:
         * localStorage.setItem("backlogHotkeyEnabled", true);
         * 
         * You only have to enter this once unless you clear your browser cache/history/etc. or are using private browsing.
         * 
         * To disable, type this into your console: 
         * localStorage.setItem("backlogHotkeyEnabled", false);
         * 
         * */
        //-----------------------------

        //------ Default Options (Useless) ------
        /**
         * pinningEnabled
         * 
         * true: pinning is enabled by default, false: disabled
         * 
         * This option is saved to your localstorage every time you toggle it in the menu.
         * Therefore, you don't have to set this option unless you are or clearing history/cache/localstorage etc. (e.g: Using private browsing mode)
         * 
         * */

        /**
         * editingEnabled
         * 
         * true: editing is enabled by default, false: disabled
         * 
         * This option is saved to your localstorage every time you toggle it in the menu.
         * Therefore, you don't have to set this option unless you are or clearing history/cache/localstorage etc. (e.g: Using private browsing mode)
         * 
         * */

        //---------------------


        const historystack = [];
        const historystack_forward = [];
        const purged_lines = [];
        const maxhistorylength = 1000;
        let scroll_fix_alignment = 0;
        let overlayModeEnabled = false;
        let overlayModeBacklog = false;
        let forgiveHistoryTimes = 0;
        let linecount = 0;
        let editPinnedButtons = false;
        let textlinesTempVisible = false;
        let isChromium = window.chrome ? true : false
        let hoverTarget = null;

        //DOMContentLoaded Start (first load)
        document.addEventListener("DOMContentLoaded", function(event) {
            //Load settings from localstorage
            loadSettings();

            switch (settings.scrollOnNewline) {
                case "disabled":
                    document.querySelector("#scroll_button").style.color = "#595959";
                    document.querySelector("#scroll_button").innerText = "⇕";
                    break;
                case "toBottom":
                    document.querySelector("#scroll_button").style.color = "";
                    document.querySelector("#scroll_button").innerText = "⇓";
                    break;
                case "toTop":
                    document.querySelector("#scroll_button").style.color = "";
                    document.querySelector("#scroll_button").innerText = "⇑";
                    break;
                default:
                    settings.scrollOnNewline = "toBottom";
                    break;
            }

            //Document Title is different for local and online pages
            if (document.location.protocol.indexOf("http") == -1) {
                document.title = document.title += " (Local)";
            } else {
                document.title = document.title += " (Online)";
            }

            //load first states
            if (settings.pinningEnabled) {
                togglePinning(true);
            }
            if (settings.editingEnabled) {
                toggleEditing(true);
            }

            //Create movable hover buttons
            createHoverButtons();

            //add button events
            //undo_button
            document.getElementById("undo_button").addEventListener("click", function() {
                historyPop();
            });

            //redo_button
            document.getElementById("redo_button").addEventListener("click", function() {
                historyPop_forward();
            });

            //edit_button
            document.getElementById("edit_button").addEventListener("click", function() {
                toggleEditing();
            });

            //add_line_button
            document.getElementById("add_line_button").addEventListener("click", function() {
                addNewLine();
            });

            //pin_button
            document.getElementById("pin_button").addEventListener("click", function() {
                togglePinning();
            });

            //overlay_button
            document.getElementById("overlay_button").addEventListener("click", function() {
                toggleOverlayMode();
            });

            //menu_button (normally you hover this one.)
            document.getElementById("menu_button").addEventListener("click", function() {
                togglePinning();
            });

            //scroll_button
            document.getElementById("scroll_button").addEventListener("click", function() {
                switch (settings.scrollOnNewline) {
                    case "disabled":
                        document.querySelector("#scroll_button").style.color = "";
                        document.querySelector("#scroll_button").innerText = "⇓";
                        settings.scrollOnNewline = "toBottom";
                        break;
                    case "toBottom":
                        document.querySelector("#scroll_button").style.color = "";
                        document.querySelector("#scroll_button").innerText = "⇑";
                        settings.scrollOnNewline = "toTop";
                        break;
                    case "toTop":
                        document.querySelector("#scroll_button").style.color = "#595959";
                        document.querySelector("#scroll_button").innerText = "⇕";
                        settings.scrollOnNewline = "disabled";
                        break;
                    default:
                        settings.scrollOnNewline = "toBottom";
                        break;
                }
                saveSettings("scrollOnNewline");
            });

            document.getElementById("remove_button").addEventListener("click", function() {
                historyPush();

                //Check whether there are any lines.
                //let linecount = document.querySelectorAll('#textlines > pre').length;
                if (linecount > 0) {

                    //Remove the first/last line.
                    switch (settings.scrollOnNewline) {
                        case "disabled":
                            document.querySelector("#textlines > pre:last-of-type").remove();
                            break;
                        case "toBottom":
                            document.querySelector("#textlines > pre:last-of-type").remove();
                            break;
                        case "toTop":
                            document.querySelector("#textlines > pre:first-of-type").remove();
                            break;
                        default:
                            break;
                    }

                    updateCounter();
                };
            });

            document.getElementById("clear_button").addEventListener("click", function(e) {

                //If shift is held, clear history as well.
                if (e.shiftKey) {
                    historystack.length = 0;
                    historystack_forward.length = 0;
                    setHistoryButtons();
                } else {
                    historyPush();
                }

                document.querySelectorAll('#textlines')[0].innerHTML = "";
                //Update the counter.
                updateCounter();
            });

            document.getElementById("go_to_last_button").addEventListener("click", function() {
                //document.querySelector("#textlines > pre:last-of-type").scrollIntoView();
                if (linecount > 0) {
                    doScroll(0, findPos(document.querySelector("#textlines > pre:last-of-type"))[1] - 200);
                }
            });

            document.getElementById("go_bottom_button").addEventListener("click", function() {
                if (linecount > 0) {
                    scrollTopBottom("bottom");
                }
            });

            //Keyboard shortcuts
            document.addEventListener("keydown", function(e) {
                //Alt + S: Toggle Editing
                if (e.altKey && e.key.toLowerCase() == "s") {
                    toggleEditing();
                    e.preventDefault();
                    //Alt + O: Toggle Backlog mode (when the overloy mode is on)
                } else if (e.altKey && e.key.toLowerCase() == "o") {
                    if (overlayModeEnabled && settings.backlogHotkeyEnabled) {
                        toggleBacklogMode();
                        e.preventDefault();
                    }
                    //Alt + 0 or }: Toggle Overlay mode (disabled by default)
                } else if ((e.altKey && e.key.toLowerCase() == "0") || e.key == "}") {
                    if (settings.overlayHotkeyEnabled) {
                        toggleOverlayMode();
                        e.preventDefault();
                    }
                }
            });


            //Non-css hover method for the menu
            document.getElementById("menucontainer").addEventListener("mouseenter", function(e) {
                handleMenuState();
            });

            document.getElementById("toprightbuttons").addEventListener("mouseleave", function(e) {
                if (!settings.pinningEnabled) {
                    //document.querySelector("#menucontainer").removeAttribute("style");
                    handleMenuState();
                }
            });

            //start checking for mouse in/out
            if (settings.autoHideYomichan) {
                checkMouseInOut();
            }

            /**
             * Start detecting hover targets so we can move the hover buttons
             */
            document.addEventListener('mouseover', function(e) {
                let textlines_Node = document.querySelector("#textlines");
                let hoverbuttons_Node = getHoverButtons();
                currentElement = e.target;
                if (e.path.includes(textlines_Node) && (currentElement.tagName == "PRE" || currentElement.classList.contains("hoverButtonsContainer"))) {
                    //Move hover buttons to target
                    if (currentElement.parentNode != textlines_Node) {
                        currentElement = currentElement.parentNode;
                    }
                    moveHoverButtons(currentElement);
                } else if (!e.path.includes(hoverbuttons_Node)) {
                    //Hide hover buttons
                    moveHoverButtons(null);
                }
            });

            //main mutation observer for new lines.
            const textlinesMutationObserver = new MutationObserver(function(records) {
                records.forEach(function(mutation) {
                    Array.prototype.forEach.call(mutation.addedNodes, function(node) {
                        try {

                            //Compatibility for prepending because most people aren't using an upgraded clipboard inserter add-on that allows prepending.
                            switch (settings.scrollOnNewline) {
                                case "toTop":
                                    let nextSib = node.nextElementSibling;
                                    //detect an append() (should have been a prepend)
                                    if (nextSib == null && forgiveHistoryTimes == 0 && linecount > 0) {
                                        document.querySelector("#textlines").prepend(node);
                                        return;
                                    }
                                    default:
                                        break;
                            }

                            //push history (delete forward history)
                            if (forgiveHistoryTimes == 0) {
                                historyPush();
                            } else {
                                --forgiveHistoryTimes;
                            }

                            //Check if the node is a history node that already has the inner pre and the hover container
                            let innerPre = node.querySelector("pre");
                            if (innerPre == null) {
                                //Not a history node

                                //check if editing is enabled
                                let preNodeOpen = settings.editingEnabled ? "<pre contenteditable=\"true\">" : "<pre>";
                                //put the added pre text into another pre so we can modify it later on.
                                node.innerHTML = preNodeOpen + node.innerHTML + "</pre>";

                                //add hover container to the line
                                createhoverContainer(node);
                            } else {
                                //History node. No need to add inner pre or container.
                                if (settings.editingEnabled) {
                                    innerPre.setAttribute("contenteditable", "true");
                                }
                            }

                            //Skip some steps while loading history
                            if (forgiveHistoryTimes == 0) {

                                //Overlay mode
                                if (overlayModeEnabled) {
                                    //If text lines were temprorarily made visible, show them.
                                    if (textlinesTempVisible) {
                                        document.querySelector("#textlines").classList.add("hidden");
                                        textlinesTempVisible = false;
                                    }
                                }
                                //update counter
                                updateCounter();

                                //purge 500 lines if its enabled.
                                if (settings.purge500LinesWhen && linecount > settings.purge500LinesWhen) {
                                    purgeExtraLines();
                                }

                                //Notify on new line if enabled (using document.title)
                                if ((settings.notifyOnNewline) && (!overlayModeEnabled) && (document.querySelector('html:hover') == null)) {
                                    notifyUsingTitle();
                                }

                                //Scroll to the top/bottom based on the current setting
                                doScrollOnNewline();

                            }

                        } catch (error) {
                            console.error(error);
                        }

                    });
                });
            });

            //mutation observer for compatibility. Because its hard to change the options. (read the readme above)
            const compatibilityMutationObserver = new MutationObserver(function(records) {
                records.forEach(function(mutation) {
                    Array.prototype.forEach.call(mutation.addedNodes, function(node) {
                        try {

                            //Everything other than "body > p" is ignored. (second part might be useless)
                            if ((node.tagName != "P") || (node.parentNode.tagName != "BODY")) {
                                return;
                            }

                            //Get new text
                            let newNode = document.createElement("pre");
                            newNode.innerHTML = node.innerText;

                            //Remove the node
                            node.remove();

                            //Append or prepend the new node depending on the current setting
                            switch (settings.scrollOnNewline) {
                                case "disabled":
                                    document.querySelector("#textlines").append(newNode);
                                    break;
                                case "toBottom":
                                    document.querySelector("#textlines").append(newNode);
                                    break;
                                case "toTop":
                                    document.querySelector("#textlines").prepend(newNode);
                                    break;
                                default:
                                    document.querySelector("#textlines").append(newNode);
                                    break;
                            }


                        } catch (error) {
                            console.error(error);
                        }

                    });
                });
            });

            //start the textlines mutation observer
            textlinesMutationObserver.observe(document.querySelector('#textlines'), {
                childList: true,
                subtree: false
            });

            //start the default options compatibility mutation observer
            compatibilityMutationObserver.observe(document.querySelector('body'), {
                childList: true,
                subtree: false
            });

            /*
            //Test
            newpree = document.createElement("pre");
            newpree.innerHTML = "loremipsum\n\nloremipsumloremipsumloremipsum\n\n\n\nloremipsumloremipsum";
            document.querySelector("#textlines").prepend(newpree);
            */

        });
        //---DOMContentLoaded end---
        //---DOMContentLoaded end---
        //---DOMContentLoaded end---

        //----------functions----------

        /**
         * Set hover target and Move Hover buttons 
         * */
        function moveHoverButtons(newTarget) {
            let hoverButtonsNode = getHoverButtons();
            if (newTarget != null) {
                hoverTarget = newTarget;
                if (hoverTarget.querySelector(".hoverButtonsBackground") == null) {
                    hoverTarget.querySelector(".hoverButtonsContainer").append(hoverButtonsNode);
                }
                //let targetXY = findPos(hoverTarget);
                //hoverButtonsNode.style.setProperty("left", `${targetXY[0]}px`);
                //hoverButtonsNode.style.setProperty("top", `${targetXY[1] + 8}px`);
                hoverButtonsNode.style.setProperty("visibility", "visible");
            } else {
                hoverButtonsNode.style.setProperty("visibility", "hidden");
            }
        }

        /**
         * Load settings from localstorage
         * */
        function loadSettings() {
            Object.entries(settings).forEach(([key, value]) => {
                settings[key] = getIfInLocalStorage(key, value);
            });

            //parse integers
            settings.purge500LinesWhen = parseInt(settings.purge500LinesWhen);
        }

        /**
         * Saves setting to localstorage
         * */
        function saveSettings(keyString = null) {
            //save all or just a specific setting
            if (keyString == null) {
                Object.entries(settings).forEach(([key, value]) => {
                    localStorage.setItem(key, value);
                });
            } else {
                localStorage.setItem(keyString, settings[keyString]);
            }
        }

        /**
         * Load setting from localstorage if it exists, otherwise keep current value.
         * Parses "true" and "false".
         * */
        function getIfInLocalStorage(itemName, currentVal) {
            let storedVal = localStorage.getItem(itemName);
            if (storedVal != null) {
                //If the stored value is true or false return those.
                switch (storedVal.toLowerCase()) {
                    case "true":
                        return true;
                    case "false":
                        return false;
                    default:
                        return storedVal;
                }
            } else {
                //No stored value
                return currentVal;
            }
        }

        //Modified from https://stackoverflow.com/a/24989958/5050478
        //Mouse in/out check for yomichan (with shadow dom disabled in settings)
        function checkMouseInOut() {
            var theTimer;
            var aFrameWasHidden = false;

            //reset or clear the timer on mouse in/out
            window.onmouseout = resetTimer;
            window.onmouseover = clearTimer;

            function doAction() {
                try {
                    //hide yomichan if it exists.
                    let yomichanFrames = document.querySelectorAll("iframe.yomichan-popup");
                    yomichanFrames.forEach(currFrame => {
                        if (currFrame.style.getPropertyValue("visibility") == "visible") {
                            currFrame.style.setProperty("visibility", "hidden", "important");
                            currFrame.classList.add("thisFrameWasHidden");
                            aFrameWasHidden = true;
                        }
                    });
                } catch (error) {
                    console.error(error);
                }
            }

            function clearTimer(e) {
                //Mouse entered the window or any element
                clearTimeout(theTimer);
                try {
                    if (aFrameWasHidden) {
                        let yomichanFrames = document.querySelectorAll("iframe.yomichan-popup");
                        yomichanFrames.forEach(currFrame => {
                            if (currFrame.classList.contains("thisFrameWasHidden")) {
                                //transition is used to prevent flashing
                                currFrame.style.setProperty("transition", "visibility 0.5s linear 0.5s");
                                currFrame.style.setProperty("visibility", "visible", "important");
                                setTimeout(() => {
                                    currFrame.style.removeProperty("transition");
                                }, 1);
                                currFrame.classList.remove("thisFrameWasHidden");
                                aFrameWasHidden = false;
                            }
                        });
                    }
                } catch (error) {
                    console.error(error);
                }
            }

            function resetTimer(e) {
                clearTimeout(theTimer);
                let reltarget = e.relatedTarget || e.toElement;
                if (!reltarget || (reltarget.nodeName == "HTML" && e.target == document.firstChild)) {
                    //Mouse left window here, do action 600 miliseconds after the mouse leaves the window
                    theTimer = setTimeout(doAction, 600);
                }
            }
        }

        //handle top right menu container hover state manually (required to support keybindings and transparency)
        function handleMenuState() {
            var menuStyles = window.getComputedStyle(document.querySelector("#menucontainer"));
            var buttonsStyles = window.getComputedStyle(document.querySelector("#toprightbuttons"));
            var menuDisplay = menuStyles.getPropertyValue("display");
            var buttonsDisplay = buttonsStyles.getPropertyValue("display");
            if ((menuDisplay == "block") && (buttonsDisplay == "block")) {
                document.querySelector("#menucontainer").setAttribute("style", "display:none;");
            } else if ((menuDisplay == "none") && (buttonsDisplay == "none")) {
                document.querySelector("#menucontainer").removeAttribute("style");
            }
        }

        //Firefox hover bug workaround: Recheck the menu state when its hidden to prevent it from being hidden permanently.
        let menustateInterval = setInterval(() => {
            //Check when not pinned and hidden manually
            if (!settings.pinningEnabled && document.querySelector('#menucontainer[style="display:none;"]')) {
                handleMenuState();
            }
        }, 175);

        //Add a hover container to every line
        function createhoverContainer(element) {
            let hoverButtons = document.createElement("div");
            element.prepend(hoverButtons);
            hoverButtons.outerHTML = `<div class="hoverButtonsContainer"></div>`;
        }

        //Create hover buttons (then we move it)
        function createHoverButtons() {

            let hoverButtons = document.createElement("div");
            document.body.append(hoverButtons);
            //svg art from https://www.svgrepo.com/collection/basicons-interface-line-icons/. MIT.
            hoverButtons.outerHTML = `
            <div class="hoverButtonsBackground" style="visibility: hidden;">
            <div class="hoverButtons hoverButtonDelete" title="Remove line"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M5 5L19 19M5 19L19 5"></path>
                </svg></div>
            <div class="hoverButtons hoverButtonReduceNewlines" title="Reduce newlines and spaces"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M 3 3 L 21 3"></path>
                <path class="middle" d="M 3 9 L 21 9 "></path>
                <path d="M 3 15 L 21 15"></path>
            </svg></div>
            <div class="hoverButtons hoverButtonCopy" title="Copy to clipboard"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M 8 6 H 16 M 8 10 H 16 M 8 14 H 12 M 6 22 H 18 C 20 22 20 22 20 20 V 4 C 20 2 20 2 19 2 H 6 C 4 2 4 2 4 4 V 20 C 4 22 4 22 6 22 Z"></path>
                </svg></div>
            <div class="hoverButtons hoverButtonDown" title="Scroll down one line"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 21V3M12 3L5 10M12 3L19 10"></path>
                </svg></div>
            <div class="hoverButtons hoverButtonUp" title="Scroll up one line"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 21V3M12 3L5 10M12 3L19 10"></path>
                </svg></div>
            </div>`;

            document.querySelector(".hoverButtonsBackground .hoverButtonDelete").addEventListener("click", function(event) {
                historyPush();

                removeLine(hoverTarget);
            });
            document.querySelector(".hoverButtonsBackground .hoverButtonReduceNewlines").addEventListener("click", function(event) {
                historyPush();

                reduceNewlines(hoverTarget);
            });
            document.querySelector(".hoverButtonsBackground .hoverButtonUp").addEventListener("click", function(event) {
                scrollUpDown(hoverTarget, event.clientY, true);
            });
            document.querySelector(".hoverButtonsBackground .hoverButtonDown").addEventListener("click", function(event) {
                scrollUpDown(hoverTarget, event.clientY, false);
            });
            document.querySelector(".hoverButtonsBackground .hoverButtonCopy").addEventListener("click", function(event) {
                let elementInner = hoverTarget.querySelector("pre");
                /**
                 * Copy Methods comparison:
                 * Copy Method 1: e.clipboardData.setData
                 *      - Chrome & Firefox can't copy newlines 
                 * Copy Method 2: navigator.clipboard.writeText
                 *      - Firefox can't copy newlines
                 * Copy Method 3: range and document.execCommand("copy")
                 *      - Chrome can't copy contenteditable nodes
                 * 
                 * Solution: use Method 2 on chromium and Method 3 on others (Firefox)
                 * 
                 * */
                //Use innerText as it converts <br>'s that were manually added with Enter into \n's. (not necessary on chrome when using display: inline-block)
                if (isChromium) {
                    //Copy Method 2
                    navigator.clipboard.writeText(elementInner.innerText).then((result) => {
                        return;
                    });
                } else {
                    //Copy Method 3
                    elementInner.focus();
                    window.getSelection().removeAllRanges();
                    let range = document.createRange();
                    range.selectNode(elementInner);
                    window.getSelection().addRange(range);
                    document.execCommand("copy");
                    window.getSelection().removeAllRanges();
                }

                /*
                //Copy Method 1
                //Add a temprorary copy event listener
                function clipListener(e) {
                    e.clipboardData.setData("text/plain", elementInner.innerText);
                    e.preventDefault();
                }
                document.addEventListener("copy", clipListener);
                document.execCommand("copy");
                document.removeEventListener("copy", clipListener);
                */
            });

            //Return the created node
            return document.querySelector(".hoverButtonsBackground");
        }

        //get hoverButtonsBackground (or recreate it)
        function getHoverButtons() {
            return document.querySelector(".hoverButtonsBackground") || createHoverButtons();
        }

        //start undo/redo buttons
        function historyPush(resetforward = true) {
            let textlinesNode = document.querySelector("#textlines").cloneNode(true);
            let dummyDiv = document.createElement("div");
            for (const element of textlinesNode.childNodes) {
                try {
                    //ignore text only nodes (that were just inserted)
                    if (element.firstChild.nodeName != "#text") {
                        let textPre = element.querySelector("pre");
                        //clean up contenteditable
                        textPre.removeAttribute("contenteditable");
                        //clean up hover buttons
                        let bgNode = element.querySelector(".hoverButtonsBackground");
                        if (bgNode) {
                            bgNode.remove();
                        }
                        //push node with inner pre and hovercontainer
                        dummyDiv.append(element.cloneNode(true));
                    }
                } catch (error) {
                    console.error(error);
                }
            }
            let historydict = {
                state: dummyDiv.innerHTML,
                linecount: textlinesNode.childNodes.length,
            }
            let historylength = historystack.push(historydict);
            if (historylength > maxhistorylength) {
                historystack.shift();
            }
            if (resetforward) {
                //reset forward history
                historystack_forward.length = 0;
            }

            setHistoryButtons();
        }

        function historyPop() {
            historyPush_forward();
            popDict = historystack.pop();
            forgiveHistoryTimes = popDict.linecount;
            document.querySelector("#textlines").innerHTML = popDict.state;

            setHistoryButtons();
            updateCounter();
        }

        function historyPush_forward() {
            let textlinesNode = document.querySelector("#textlines").cloneNode(true);
            let dummyDiv = document.createElement("div");
            for (const element of textlinesNode.childNodes) {
                try {
                    //ignore text only nodes (that were just inserted)
                    if (element.firstChild.nodeName != "#text") {
                        let textPre = element.querySelector("pre");
                        //clean up contenteditable
                        textPre.removeAttribute("contenteditable");
                        //clean up hover buttons
                        let bgNode = element.querySelector(".hoverButtonsBackground");
                        if (bgNode) {
                            bgNode.remove();
                        }
                        //push node with inner pre and hovercontainer
                        dummyDiv.append(element.cloneNode(true));
                    }
                } catch (error) {
                    console.error(error);
                }
            }
            let historydict = {
                state: dummyDiv.innerHTML,
                linecount: textlinesNode.childNodes.length,
            }
            let historylength_forward = historystack_forward.push(historydict);
            if (historylength_forward > maxhistorylength) {
                historystack_forward.shift();
            }
        }

        function historyPop_forward() {

            historyPush(false);
            popDict = historystack_forward.pop();
            forgiveHistoryTimes = popDict.linecount;
            document.querySelector("#textlines").innerHTML = popDict.state;

            setHistoryButtons();
            updateCounter();
        }

        function setHistoryButtons() {
            if (historystack.length >= 1) {
                document.querySelector("#undo_button").removeAttribute("disabled");
            } else {
                document.querySelector("#undo_button").setAttribute("disabled", "");
            }
            if (historystack_forward.length >= 1) {
                document.querySelector("#redo_button").removeAttribute("disabled");
            } else {
                document.querySelector("#redo_button").setAttribute("disabled", "");
            }
        }
        //end undo/redo buttons

        //toggle overlay mode
        function toggleOverlayMode() {

            const overlayCounterHTML = `<div id="counter" class="overlaycounter" title="No. of characters / No. of lines
Undo/Redo functionality will be slower the more lines you have.">0 / 0</div>`;

            const overlayButtonsHTML = `<div id="overlay_buttons_container">
    <div id="overlay_down_button" style="margin-right: 8px;" title="Scroll Down">▼</div>
    <div id="overlay_up_button" style="margin-right: 26px;" title="Scroll Up">▲</div>
    <div id="overlay_top_button" style="margin-right: 8px; font-size: 17px; margin-top: 2px;" title="Scroll to the Top">🢁</div>
    <div id="overlay_bottom_button" style="margin-right: 22px; font-size: 17px; margin-top: 6px;" title="Scroll to the Bottom">🢃</div>
    <div id="overlay_text_button" style="padding-left: 4px; margin-right: 8px; font-size: 18px; margin-top: 4px; font-weight: bold; font-family: Calibri; transform: scale(1.33, 1.05);" title="Toggle Text Visibility
If you hover this button while it is enabled, text lines will be visible until a new line is added." class="">¶</div>
    <div id="overlay_background_button" style="font-size: 19px; margin-top: 2px;" title="Toggle Backlog Mode">☯</div>
</div>`;

            let htmlNode = document.querySelector("html");
            let cssNode = document.querySelector("#overlaycss");

            if (htmlNode.classList.contains("overlaymode")) {
                //turn overlay mode off
                document.title = document.title.replace(" (Overlay Mode)", "");

                htmlNode.classList.remove("overlaymode");
                cssNode.setAttribute("media", "not all");
                document.querySelector("#overlay_button").classList.remove("overlay_button_on");
                scroll_fix_alignment = 0;
                //Remove overlay buttons
                document.querySelector("#overlay_buttons_container").remove();
                //Set the regular counter's value and remove overlay counter 
                document.querySelector(".countercontainer #counter").textContent = document.querySelector("#toprightbuttons .overlaycounter").textContent;
                document.querySelector(".overlaycounter").remove();

                //If backlog mode is enabled, disable it.
                if (overlayModeBacklog) {
                    toggleBacklogMode();
                }
                //If text visibility button is toggled, disable it.
                if (document.querySelector("#textlines.hidden")) {
                    toggleTextVisibility();
                }

                overlayModeEnabled = false;

                //Scroll to the top/bottom based on the current setting
                doScrollOnNewline();

            } else {
                //Move hover buttons to body
                document.body.append(getHoverButtons());

                //turn overlay mode on
                document.title = document.title + " (Overlay Mode)";

                htmlNode.classList.add("overlaymode");
                cssNode.setAttribute("media", "all");
                document.querySelector("#overlay_button").classList.add("overlay_button_on");
                scroll_fix_alignment = 12;

                //Add overlay counter and set its value
                document.querySelector("#toprightbuttons").insertAdjacentHTML("afterbegin", overlayCounterHTML);
                document.querySelector("#toprightbuttons .overlaycounter").textContent = document.querySelector(".countercontainer #counter").textContent;

                //Add overlay buttons
                let newContainerDiv = document.createElement("div");
                document.body.prepend(newContainerDiv)
                newContainerDiv.outerHTML = overlayButtonsHTML;
                //Overlay button events
                document.getElementById("overlay_down_button").addEventListener("click", function(event) {
                    if (linecount > 0) {
                        //scrollFirstLast("last", 4);
                        document.querySelector("body").scrollBy(0, 80);
                    }
                });
                document.getElementById("overlay_up_button").addEventListener("click", function(event) {
                    if (linecount > 0) {
                        document.querySelector("body").scrollBy(0, -80);
                    }
                });
                document.getElementById("overlay_bottom_button").addEventListener("click", function(event) {
                    scrollFirstLast("last");
                });
                document.getElementById("overlay_top_button").addEventListener("click", function(event) {
                    scrollFirstLast("first");
                });
                document.getElementById("overlay_background_button").addEventListener("click", function(event) {
                    toggleBacklogMode();
                });
                document.getElementById("overlay_text_button").addEventListener("click", function(event) {
                    toggleTextVisibility();
                });

                //When hovered, temprorarily show text lines until a new line is added (only while the button is turned on)
                document.getElementById("overlay_text_button").addEventListener("mouseover", function(event) {
                    if (!textlinesTempVisible && event.target.classList.contains("button_on")) {
                        document.querySelector("#textlines").classList.remove("hidden");
                        textlinesTempVisible = true;
                    }
                });

                overlayModeEnabled = true;

                //Scroll to the top/bottom based on the current setting
                doScrollOnNewline();

            }
        }

        //Overlay Mode: Toggle text visibility
        function toggleTextVisibility() {
            let textbutton = document.getElementById("overlay_text_button");
            if (textbutton.classList.contains("button_on")) {
                document.querySelector("#textlines").classList.remove("hidden");
                textbutton.classList.remove("button_on");
            } else {
                document.querySelector("#textlines").classList.add("hidden");
                textbutton.classList.add("button_on");
            }
            //turn temp visibility off
            textlinesTempVisible = false;
        }

        //Overlay Mode: Toggle backlog mode
        function toggleBacklogMode() {
            //disable backlog mode
            if (overlayModeBacklog) {
                overlayModeBacklog = !overlayModeBacklog;

                //Move hover buttons to body
                document.body.append(getHoverButtons());

                document.querySelector("body").classList.remove("backlogmode");
                event.target.classList.remove("button_on");

                //Scroll to the top/bottom based on the current setting
                doScrollOnNewline();

                //enable backlog mode
            } else {
                overlayModeBacklog = !overlayModeBacklog;
                document.querySelector("body").classList.add("backlogmode");
                event.target.classList.add("button_on");

                //Scroll to the top/bottom based on the current setting
                doScrollOnNewline();
            }
        }

        //toggle editing
        function toggleEditing(firstload = false) {
            if (firstload) {
                settings.editingEnabled = !settings.editingEnabled;
            }
            if (settings.editingEnabled) {
                //disable editing, set button style
                const linesArray = document.querySelectorAll("#textlines>pre>pre").forEach(element => {
                    element.removeAttribute("contenteditable");
                });
                document.querySelector("#edit_button").classList.remove("edit_button_on");
                //also unpin if we pinned it
                if (editPinnedButtons) {
                    togglePinning();
                }
            } else {
                //push to history, enable editing, set button style
                historyPush();
                const linesArray = document.querySelectorAll("#textlines>pre>pre").forEach(element => {
                    element.setAttribute("contenteditable", "true");
                });
                document.querySelector("#edit_button").classList.add("edit_button_on");
                //also pin the buttons as well
                if (document.querySelectorAll(".pin_button_on").length != 1) {
                    editPinnedButtons = true;
                    togglePinning();
                }
            }
            settings.editingEnabled = !settings.editingEnabled;
            saveSettings("editingEnabled");
        }

        //add new line
        function addNewLine() {
            if (!settings.editingEnabled) {
                toggleEditing();
            }

            newpre = document.createElement("pre");
            newpre.innerHTML = "";
            //append or prepend the new line based on the current setting, prepend is default.
            switch (settings.scrollOnNewline) {
                case "disabled":
                    document.querySelector("#textlines").prepend(newpre);
                    break;
                case "toBottom":
                    document.querySelector("#textlines").append(newpre);
                    break;
                case "toTop":
                    document.querySelector("#textlines").prepend(newpre);
                    break;
                default:
                    document.querySelector("#textlines").prepend(newpre);
                    break;
            }
            //Workaround for focusing contenteditable (https://stackoverflow.com/a/37162116/5050478)
            setTimeout(function() {
                newpre.querySelector("pre").focus();
            }, 0);

        }

        //toggle pinning
        function togglePinning(firstload = false) {
            if (firstload) {
                settings.pinningEnabled = !settings.pinningEnabled;
            }
            if (settings.pinningEnabled) {
                document.querySelector("#toprightbuttons").removeAttribute("style");
                document.querySelector("#pin_button").classList.remove("pin_button_on");
                editPinnedButtons = false;
            } else {
                document.querySelector("#toprightbuttons").setAttribute("style", "display:inline-block;");
                document.querySelector("#pin_button").classList.add("pin_button_on");
            }
            //handle menu button visibility (for edge cases)
            handleMenuState();
            settings.pinningEnabled = !settings.pinningEnabled;
            if (!editPinnedButtons) {
                saveSettings("pinningEnabled");
            }
        }

        //purge extra lines
        function purgeExtraLines() {
            purged_lines.push("////// STARTED PURGING LINES //////");
            //es6 NodeList to array
            let purgeArray = [...document.querySelectorAll("#textlines > pre")];
            switch (settings.scrollOnNewline) {
                case "toTop":
                    //bottom 500
                    purgeArray = purgeArray.slice(-500);
                    break;
                case "disabled":
                case "toBottom":
                default:
                    //top 500
                    purgeArray = purgeArray.slice(0, 499);
                    break;
            }
            purgeArray.forEach(element => {
                purged_lines.push(element.innerText);
                element.remove();
            });
            purged_lines.push("////// FINISHED PURGING LINES //////");
            console.log("🧹 Purged 500 lines. Check purged_lines array. 🧹");
        }

        //notify new lines with a document.title change
        function notifyUsingTitle() {
            backupTitle = document.title.replace(/☑ |✔ /gim, "");

            //Add notification icon
            document.title = "✔ " + backupTitle;

            //Blink the icon
            setTimeout(() => {
                document.title = "☑ " + backupTitle;
            }, 800);
            //Go back to the original title
            setTimeout(() => {
                document.title = backupTitle;
                //(test) lame workaround to prevent being stuck in between
                if (document.title != backupTitle) {
                    setTimeout(() => {
                        document.title = backupTitle;
                    }, 500);
                }
            }, 1600);
        }

        //Pick scroll method (body or window depending on the current view)
        function doScroll(valueX, valueY) {
            if (overlayModeEnabled && !overlayModeBacklog) {
                document.querySelector("body").scroll(valueX, valueY);
            } else {
                window.scroll(valueX, valueY);
            }
        }

        //scrolling
        function doScrollOnNewline() {
            switch (settings.scrollOnNewline) {
                case "disabled":
                    break;
                case "toBottom":
                    scrollFirstLast("last");
                    break;
                case "toTop":
                    scrollFirstLast("first");
                    break;
                default:
                    break;
            }
        }

        function scrollFirstLast(scrollTo) {
            //Cancel if there is no first or last
            if (linecount <= 0) {
                return;
            }
            //Use a different Y offset depending on the current mode
            let offsetY = overlayModeEnabled ? 12 : 24;
            if (scrollTo == "last") {
                let target = document.querySelector("#textlines > pre:last-of-type");
                doScroll(0, findPos(target)[1] - offsetY);
                //set overlay mode hover target
                if (overlayModeEnabled && !overlayModeBacklog) {
                    moveHoverButtons(target);
                }
            } else if (scrollTo == "first") {
                let target = document.querySelector("#textlines > pre:first-of-type");
                doScroll(0, findPos(target)[1] - offsetY);
                //set overlay mode hover target
                if (overlayModeEnabled && !overlayModeBacklog) {
                    moveHoverButtons(target);
                }
            }
        }

        function scrollTopBottom(toTop) {
            let scrollSelector = overlayModeEnabled ? document.querySelector("body") : document.querySelector("html");
            if (toTop == "top") {
                scrollSelector.scroll(0, 0);
                //set overlay mode hover target
                if (overlayModeEnabled && !overlayModeBacklog) {
                    moveHoverButtons(document.querySelector("#textlines > pre:first-of-type"));
                }
            } else if (toTop == "bottom") {
                scrollSelector.scrollIntoView(false);
                //set overlay mode hover target
                if (overlayModeEnabled && !overlayModeBacklog) {
                    moveHoverButtons(document.querySelector("#textlines > pre:last-of-type"));
                }
            }
        }

        function scrollUpDown(element, clientY, scrollUp) {
            //get the pre
            let elementOuter = element.closest("pre");
            let scrollto = null;
            try {
                if (scrollUp) {
                    //Scroll to the previous element if it exists, otherwise do nothing.
                    scrollto = elementOuter.previousElementSibling;
                } else {
                    //Scroll to the next element if it exists, otherwise do nothing.
                    scrollto = elementOuter.nextElementSibling;
                }
                if (!scrollto) {
                    //Do nothing.
                    return;
                } else {

                    //set overlay mode hover target. Also disable cursor location offset
                    if (overlayModeEnabled && !overlayModeBacklog) {
                        moveHoverButtons(scrollto);
                        clientY = 0;
                    }
                    //Scroll to the element using mouse clientY and scroll_fix_alignment
                    doScroll(0, findPos(scrollto)[1] - clientY - scroll_fix_alignment);
                    //scrollto.scrollIntoView();
                }
                return;
            } catch (error) {
                console.error(error);
            }
        }

        //find an element's position in the whole page
        function findPos(obj) {
            let curleft = curtop = 0;
            if (obj && obj.offsetParent) {
                do {
                    curleft += obj.offsetLeft;
                    curtop += obj.offsetTop;
                } while (obj = obj.offsetParent);
                values = [curleft, curtop];
                return values;
            }
        }

        function removeLine(element) {
            let elementOuter = element.closest("pre");
            //Move the hover buttons to the next target
            moveHoverButtons(elementOuter.nextElementSibling || elementOuter.previousElementSibling);

            elementOuter.remove();
            updateCounter();
        }

        function reduceNewlines(element) {
            let elementInner = element.closest("pre").querySelector("pre");
            //Use innerText as it converts <br>'s that were manually added with Enter into \n's.
            let modifystring = elementInner.innerText;
            //trim newline+spaces at the start (once)
            modifystring = modifystring.replace(/^[\r\t\f\v 　\u00a0]*\n/, "");
            //trim spaces+newline at the end (once)
            modifystring = modifystring.replace(/[\r\t\f\v 　\u00a0]*\n$/, "");
            //clean spaces
            modifystring = modifystring.replace(/\n[\r\t\f\v 　\u00a0]*/gm, "\n");
            //reduce newlines by half (at least 1) (6->3, 5->3, 4->2, 3->2, 2->1, 1->0 etc...)
            modifystring = modifystring.replace(/(\n(\n+?))|(\n+?)/gm, "$2$3");
            //Use textContent or innerHTML to put the clean string into the div (without <br>'s).
            elementInner.textContent = modifystring;
        }

        //Note: linecount is used for more than just the #counter
        function updateCounter() {
            let charlength = 0;
            linecount = 0;
            try {
                let lines = document.querySelectorAll("#textlines > pre > pre");
                linecount = lines.length;
                lines.forEach(element => {
                    charlength += element.textContent.length;
                });
            } catch (error) {
                console.error(error);
            }
            document.querySelector("#counter").textContent = charlength + ' / ' + linecount;
            return;
        }

    </script>

    <!-- This is the main css that styles everything -->
    <style id="maincss" type="text/css">
        /* CSS styles will be overhauled with the svg buttons update (t.b.d.)*/

        html {
            overflow-y: scroll;
            scrollbar-width: thin;
        }

        body {
            margin-top: 14px;
            margin-left: 2%;
            margin-right: 2%;
            margin-bottom: 300px;
            background-color: #202020;
            color: #BCBCBC;
            font-size: 1.3em;
            font-weight: 400;
            /* Global font. */
            font-family: "Noto Sans JP Light";
            /*font-family: "Noto Sans JP Light", "Meiryo", "MS Gothic", system-ui;*/
            /*font-family: "IPAGothic", "Sazanami Gothic", "Kochi Gothic", "VL Gothic", "Ume Gothic", "Pro W3", "Hiragino Kaku Gothic Pro", "Osaka Mono", "Osaka", "MS Gothic", "Meiryo", "M+ 1m";*/
        }

        /* Main text style */
        pre {
            font-family: inherit;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0em 0em 0em 0em;
            padding-bottom: 0px;
            /* Prevent contenteditable outline from covering the caret */
            outline-offset: 2px;
        }

        #textlines > pre {
            border-bottom: #414141 solid 1px;
            padding-bottom: 29px;
            padding-top: 10px;
        }

        #textlines > pre > pre {
            /* While editable: Prevent chrome from adding <div><br></div> packages when Enter is pressed */
            display: inline-block;
            width: 100%;
        }

        /* Preemptively hide compatibility lines to prevent flashing */
        body > p {
            display: none;
        }

        /* Top right buttons & counter css */
        .countercontainer {
            bottom: 1px;
            right: 1px;
            position: fixed;
            display: inline-block;
            font-size: 1.4em;
            user-select: none;
        }

        #counter {
            font-size: 11px;
            padding: 4px 6px 4px 6px;
            margin-right: 0px;
            border-radius: 4px !important;
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            line-height: 100%;
            float: left;
            font-family: "Calibri";
        }

        .buttoncontainer {
            right: 1px;
            top: 1px;
            position: fixed;
            display: inline-block;
            font-family: "VL Gothic";
            user-select: none;
            z-index: 1;
        }

        #toprightbuttons:hover,
        #menucontainer:hover ~ #toprightbuttons {
            display: inline-block !important;
        }

        #toprightbuttons {
            z-index: 3;
            display: none;
        }

        .buttoncontainer > div:not(#counter):hover {
            color: #d7d7d7;
            fill: #d7d7d7;
            background-color: rgba(27, 27, 27, 1.00);
        }

        .buttoncontainer > #pin_button:hover {
            filter: brightness(140%) grayscale(100%);
            background-color: rgba(19, 19, 19, 1.00) !important;
        }

        .buttoncontainer > div,
        .countercontainer > div {
            border-radius: 4px !important;
            margin-right: 5px;
        }

        #pin_button {
            padding: 2px 3px 5px 4px;
            font-size: 10px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            float: left;
            cursor: pointer;
            filter: grayscale(100%);
            font-family: "Segoe UI", "Noto Sans JP Light", "Arial";
        }

        .pin_button_on > #pintext {
            transform: rotate(-45deg) !important;
            margin-right: 1px;
            margin-left: -1px;
        }

        #clear_button {
            font-size: 13px;
            padding: 0px 4px 2px 4px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            float: left;
            cursor: pointer;
            font-family: "Noto Sans JP Light", "Arial";
        }

        #overlay_button {
            font-size: 18px;
            padding: 0px 6px 5px 5px;
            line-height: 16px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            float: left;
            cursor: pointer;
            font-family: "Calibri";
        }

        #overlay_button.overlay_button_on {
            box-shadow: inset 0px 0px 3px 2px rgb(69, 183, 44, 0.5);
            color: rgb(51, 144, 31) !important;
        }

        #scroll_button {
            font-size: 14px;
            padding: 1px 3px 2px 4px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #a6a6a6;
            float: left;
            cursor: pointer;
            /*font-family: "Lucida Sans Unicode";*/
        }

        #edit_button {
            font-size: 13px;
            padding: 1px 4px 2px 4px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            float: left;
            cursor: pointer;
        }

        .edit_button_on {
            box-shadow: inset 0px 0px 3px 2px rgb(69, 183, 44, 0.5);
            color: rgb(73, 196, 47) !important;
        }

        #add_line_button {
            background-color: rgba(25, 25, 25, 0.65);
            float: left;
            cursor: pointer;
            padding: 3px 4px 4px 4px;
            width: 14px;
            height: 14px;
            fill: #9f9f9f;
        }

        #add_line_button svg {
            transform: translate(0px, -7px);
        }

        .undoredoButtons {
            background-color: rgba(25, 25, 25, 0.65);
            color: #848484;
            height: 10px;
            width: 10px;
            float: left;
            padding: 5px 0px 6px 6px;
            cursor: pointer;
            pointer-events: initial;
        }

        .undoredoButtons svg {
            transform: translate(0px, -11px);
        }

        .undoredoButtons > div:hover,
        #remove_button:hover {
            color: #ccc !important;
        }

        .undoredoButtons[disabled] {
            pointer-events: none;
            color: #4e4e4e;
        }

        #undo_button {
            margin-right: 0px;
            padding-right: 3px;
            border-radius: 4px 0px 0px 4px !important;
        }

        #redo_button {
            border-radius: 0px 4px 4px 0px !important;
            padding-left: 3px;
            padding-right: 6px;
        }

        #menu_button {
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            float: right;
            font-size: 16px;
            padding: 0px 4px 1px 4px;
            margin-right: 0px;
            cursor: pointer;
            line-height: 20px;
        }

        #remove_button {
            padding: 1px 3px 1px 3px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #868686;
            float: right;
            font-size: 15px;
            margin-right: 0px;
            cursor: pointer;
        }

        /* Top/Bottom buttons css */
        #go_to_last_button {
            margin-left: 120px;
            bottom: -20px;

            position: relative;
            cursor: pointer;
            user-select: none;
            font-size: 22px;
            width: 24px;
            filter: opacity(20%);
        }

        #go_to_last_button:hover {
            filter: opacity(40%);
        }

        #go_bottom_button {
            margin-left: 120px;
            top: -7px !important;
            position: absolute;
            cursor: pointer;
            user-select: none;
            font-size: 22px;
            width: 24px;
            filter: opacity(20%);
        }

        #go_bottom_button:hover {
            filter: opacity(40%);
        }

        /* Hover buttons CSS */
        .hoverButtonsContainer {
            width: 105px;
            margin-top: -22px;
            height: 20px;
            position: absolute;
            display: flex;
            background-color: transparent;
            user-select: none;
        }

        .hoverButtonsContainer:hover,
        pre:hover > .hoverButtonsContainer > .hoverButtonsBackground {
            display: flex !important;
        }

        .hoverButtonsBackground:hover,
        .hoverButtonsBackground:hover > .hoverButtons,
        .hoverButtonsContainer:hover .hoverButtons {
            opacity: 90%;
        }

        body > .hoverButtonsBackground {
            visibility: hidden !important;
        }

        .hoverButtonsBackground {
            height: 15px;
            padding: 3px 4px 6px 10px;
            border-radius: 6px;
            position: absolute;
            display: flex;
            flex-direction: row;
            justify-content: space-evenly;
            background-color: #1c1c1c;
            z-index: 555;
            font-size: 14px;
            user-select: none;
        }

        .hoverButtons {
            cursor: pointer;
            margin-right: 0px;
            color: #adadad;
            opacity: 40%;
        }

        .hoverButtons:hover {
            filter: brightness(1.5);
        }

        .hoverButtonDelete svg {
            stroke: #adadad;
            stroke-width: 3.2px !important;
            stroke-linecap: round;
            width: 21px;
            margin: -3px 0px 0 -8px;
        }

        .hoverButtonReduceNewlines svg {
            stroke: #adadad;
            stroke-width: 2.5px;
            margin: 0px 0px 0px -3px;
            width: 24px;
            transform: scale(0.80, 1);
            /* stroke-linecap: round; */
        }

        /* 
        .hoverButtonReduceNewlines svg .middle {
            stroke-width: 3px;
        }
        */

        .hoverButtonCopy svg {
            stroke: #adadad;
            stroke-width: 3px;
            width: 17px;
            margin: -3px 0 0 -1px;
            stroke-linecap: round;
            transform: scale(0.99, 0.94);
        }

        .hoverButtonDown svg,
        .hoverButtonUp svg {
            stroke: #adadad;
            stroke-width: 4px;
            width: 17px;
            stroke-linejoin: round;
            stroke-linecap: round;
            margin: -3px -2px 0px 0px;
        }

        .hoverButtonDown svg {
            margin: -3px 0 0 1px;
            transform: rotate(180deg);
        }

        /* Webkit compatibility: Thinner Scrollbar (similar to Firefox) */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: #7a7a7b !important;
        }

        ::-webkit-scrollbar-track {
            background: #232327;
        }

        /* Lighter background colors for buttons */
        /* 
        .buttoncontainer>div,
        .hoverButtonsBackground {
            background-color: rgb(60, 60, 60) !important;
        }
        */

    </style>

    <!-- This css is only for the overlay mode -->
    <style id="overlaycss" type="text/css" media="not all">
        .overlaymode > body {
            background-color: #000;
            margin-bottom: -31px;
            margin-top: 0px;
            overflow: auto;
            height: 134px;
            /* Firefox */
            scrollbar-width: none;
        }

        .overlaymode > body.backlogmode {
            background-color: #202020;
            height: 100%;
        }

        .overlaymode > body.backlogmode > #textlines {
            margin-top: 16px;
        }

        .overlaymode > body.backlogmode > #textlines > pre {
            margin-top: 0px;
            margin-bottom: 10px;
            border-bottom: #414141 solid 1px;
        }

        .overlaymode #textlines.hidden {
            visibility: hidden;
        }

        .overlaymode #textlines {
            margin-top: 24px;
        }

        .overlaymode #textlines > pre {
            border-bottom: none;
            margin-bottom: 86px;
            margin-top: 160px;
            margin-left: auto;
            margin-right: auto;
            width: 56%;
        }

        .overlaymode #textlines > pre > pre {
            color: #fcfcfc;
            text-shadow: 0px 0px 2px #0b0b0b;
            -webkit-text-stroke: .2px #eee;
            /*text-shadow: -1px -1px 0 #101010, 0 -1px 0 #101010, 1px -1px 0 #101010, 1px 0 0 #101010, 1px 1px 0 #101010, 0 1px 0 #101010, -1px 1px 0 #101010, -1px 0 0 #101010;*/
            font-size: 1.154em;
            line-height: 1.15em;
            font-family: "MS Gothic";
        }

        .overlaymode #go_to_last_button,
        .overlaymode #go_bottom_button {
            display: none;
        }

        .overlaymode #toprightbuttons {
            background-color: #50505099;
            border-radius: 4px;
            top: 0px;
        }

        .overlaymode #counter.overlaycounter {
            padding: 5px 6px 5px 6px;
            margin-right: 6px;
        }

        .overlaymode #menu_button {
            font-size: 11.5px;
            padding: 0px 2px 0px 1px;
            line-height: 13px;
        }

        .overlaymode .countercontainer {
            display: none;
        }

        /* overmay mode hover buttons */
        .overlaymode .hoverButtonsContainer {
            position: relative;
        }

        .overlaymode body:not(.backlogmode) #textlines .hoverButtonsBackground {
            visibility: visible !important;
        }

        .overlaymode body:not(.backlogmode) .hoverButtonsBackground {
            display: flex !important;
            position: fixed;
            transform: scale(1.0, 0.10) translate(0px, -108px);
            padding-bottom: 4px;
            top: 0px;
            left: 23.0%;
        }

        .overlaymode body:not(.backlogmode) .hoverButtonsBackground:hover,
        .overlaymode body:not(.backlogmode) .hoverButtonsContainer:hover .hoverButtonsBackground {
            transform: scale(1.0, 1.0) translate(0px, -1px);
            padding: 2px 5px 6px 11px;
            opacity: 1;
        }


        .overlaymode body.backlogmode .hoverButtonsContainer {
            transform: scale(1.00, 1.00) translate(0px, -8px);
        }

        .overlaymode body:not(.backlogmode) #overlay_buttons_container:not(:hover) #overlay_bottom_button {
            margin-top: -5px;
        }

        /* Style new overlay buttons */
        .overlaymode #overlay_buttons_container {
            transform: scale(1, 0.08) translate(0px, -180px);
            border-radius: none;
        }

        .overlaymode #overlay_buttons_container:hover {
            transform: scale(1, 1) translate(0px, -8px);
            border-radius: 6px;
        }

        .overlaymode #overlay_buttons_container > div {
            opacity: 40%;
            cursor: pointer;
            user-select: none;
        }

        .overlaymode #overlay_buttons_container > div:hover {
            opacity: 80%;
        }

        .overlaymode #overlay_buttons_container > div.button_on {
            color: #a6f57ed6;
            opacity: 90%;
        }

        .overlaymode #overlay_buttons_container {
            /*transform: translateX(-50%);*/
            /*height: 2px;*/
            position: fixed;
            top: 0px;
            background-color: #1D1D1D;
            color: #fff;
            left: 30%;
            display: flex;
            padding: 0px 10px 1px 10px;
            font-family: Segoe UI;
            font-size: 21px;
        }

        ::-webkit-scrollbar {
            width: 0 !important;
        }

    </style>

</head>


<body>
    <div id="go_bottom_button" title="Scroll to the bottom">🡻</div>
    <div id="menucontainer" class="buttoncontainer">
        <!-- This is the div used for the "show menu menu" button. -->
        <div id="menu_button" title="Menu">⚙</div>
    </div>
    <div id="toprightbuttons" class="buttoncontainer">
        <!-- This is the div used for the "Toggle Overlay Mode" button. -->
        <div id="overlay_button" title="Toggle Overlay Mode (experimental)
Toggles the page's style. Currently in testing.">α</div>
        <!-- This is the div used for the "Pin menu" button. -->
        <div id="pin_button" title="Pin/Unpin the menu">
            <div id="pintext">📌</div>
        </div>
        <!-- This is the div used for the "Clear all lines" button. 🛇⊘∅ -->
        <div id="clear_button" title="Clear all lines.
Clears the history as well when clicked while holding Shift.">⊘</div>
        <!-- This is the div used for the "Toggle scroll to bottom a when new line is added" button. -->
        <div id="scroll_button" title="Scroll to bottom(⇓)/top(⇑)/nowhere(⇕) when a new line is added.
Also prepends new lines by default if set to top(⇑).">⇓</div>
        <!-- This is the div used for the "Enable editing" button. -->
        <div id="edit_button" title="Enables line editing.
History is saved right when you enable this,
so disable it if you want when you are done.
Toggle Shortcut: Alt + S">🖉</div>
        <!-- This is the div used for the "Add a new line" button. -->
        <div id="add_line_button" title="Adds a new line and enables editing.
Saves history when pressed.">
            <!-- Octicons v11.0.0, License: MIT, Copyright (c) 2020 GitHub Inc. -->
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M8 2a.75.75 0 01.75.75v4.5h4.5a.75.75 0 010 1.5h-4.5v4.5a.75.75 0 01-1.5 0v-4.5h-4.5a.75.75 0 010-1.5h4.5v-4.5A.75.75 0 018 2z"></path>
            </svg>
        </div>
        <!-- These are the divs used for the "Undo/Redo" buttons. -->
        <div id="undo_button" class="undoredoButtons" disabled="" title="Undo">
            <div>
                <!-- Font Awesome Icons, CC BY 4.0 License, https://fontawesome.com/license/free -->
                <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="undo-alt" class="svg-inline--fa fa-undo-alt fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z"></path>
                </svg>
            </div>
        </div>
        <div id="redo_button" class="undoredoButtons" disabled="" title="Redo">
            <div>
                <!-- Font Awesome Icons, CC BY 4.0 License, https://fontawesome.com/license/free -->
                <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="redo-alt" class="svg-inline--fa fa-redo-alt fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z"></path>
                </svg>
            </div>
        </div>
        <!-- This is the div used for the "remove last line" button. -->
        <div id="remove_button" title="Remove first/last line
Removes the first line when auto scroll is set to 'Scroll to top(⇑)'">✖</div>
    </div>
    <div class="countercontainer">
        <!-- This is the div used for the counter. -->
        <div id="counter" title="No. of characters / No. of lines
Undo/Redo functionality will be slower the more lines you have.">0 / 0</div>
    </div>
    <div style="display:none;">
        <!-- Dummy div for buttons-->
    </div>

    <!-- inserted pre tags go here -->
    <div id="textlines"></div>

    <div id="go_to_last_button" title="Scroll to the start of the last item">🡹</div>

</body>

</html>
