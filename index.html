<html>

<head>
    <meta charset="utf-8">
    <!-- Title -->
    <title>Clipboard Inserter HTML Enhanced</title>
    <!-- Scary base64 encoded favicon (å°) -->
    <link href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC90lEQVQ4jU2SW2tVRxTH19z23uca05zEJEZzDpEmNbXeQCoqIiheCkUE8+IX8M2nfoJ+gD4UCnkqtEie+tiAlQZFRMUgCW3qJTHectMk5mSffc6evWdmTdnHfQ4ZWDDMrPn91//PkL6Fhw4A8LREWiwpPXH7JD0yPEdHylUAMACgAUCllew1TZuTxwnIBYAMAOTMH1Nn1aPZcf3rn9N2cbkXALIA4KU9LVFGdyg76eMsNyYPq5un5NpagRAi3P4SaZ59hrQAzUl5OkFL3dO/T45B1os5pwmsudzFpXL13swFcv74BN2/dyk9tomtneqe/m3ymrz/5AfqOHbXoeHbLcDWrb9+ri3Md+dW1k87P94YAwBMM1FtC24Ue7QeDip/O0OFAEGI1wJQziL1YRVMrdYHkw9Ocq3bwbdDdJRycWX9TNLIvGyWgXVbgP6Dlan86DdhY2E+Z2ZejDGDIgVQ2hTQmmfrYcYqrEAcAWekym3TWnMNVPreusUi6pX3gNvhCfF6+QsAIEmlAEODv5+c0X415L390NlVeEWtpS2AUIqXSh3PRHkIwtUlG01Nf5+REWvaS9JkxpDw1fK5xrs3mUJlSO4r9z4l1tp2Bmj14GD3dLE8JOW7N0IurV8WSiX3TRXLHv87IP3GsWREJhzc1dPx1qJVLYAlpNHVVVwkwuG48REQYaj0YYN5MrK0ENStnX8/jEGA2a8P656O7AxDbFjEHQDwAcAveWyu+7ur6uLonuu7N6s2IyPkRT/AL78auDe7tnn/U6N46sRI/0QDMQSDcduCMQlAXTqw56dEUKPaWNn2sVALNO+s+ti55eOVctcvFHFii0B05+4/N2tSfxvNzUK+sh+E1gEQCJFSh6IFrk09Vw+VGyvDPRlpL4ripMkwZg3jkjG6UXv5H9BSz+evLON6UMxXg3wO3FgRS6AmPbeeTMUNY7F0XZ9pQ5FSP3IFHq30jEfB8CgHYB2CPM+HYfCp1Lm9trsUK8EtsVZGjhNGjtD/Awy3cVQ9IGG0AAAAAElFTkSuQmCC" rel="icon" type="image/png" />
    <script>
        /*
        /////////////////////////////////////////////////////////////////////////
        /////// Downloadable HTML for Clipboard Inserter (Enhanced) v2.1  ///////
        /////////////////////////////////////////////////////////////////////////

            ------ General Info ------
            ------ General Info ------

        The following Non-default Clipboard Inserter settings are NOT required but highly suggested:
        - element name: pre
        - container selector: #textlines

        You can switch to prepending mode by setting the "Scroll" button to top (Up arrow: â‡‘)
        (Or you can just use a modified Clipboard Inserter addon)

        Hover the buttons to read their descriptions.
        Both appending and prepending should work for all buttons and functionality. (Even if you don't have a modified Clipboard Inserter)

        Keyboard shortcuts:
        - Alt + E: Toggle Editing

        â— Default Options and Hidden features:
        - â— You can set a few default options right after the "old readme" below.  
          - â— You don't have to change these options unless you are using private browsing mode (or clearing history/cache/localstorage etc.)
            - â— Except for the "auto hide yomichan popups" option. (Which requires the setting "Use a secure container around popups" to be off in yomichan's options.)

        Original page was inspired/borrowed from: https://pastebin.com/raw/HxjV6YrB (Only a few lines of the code left) 
        Which was found here: https://pastebin.com/gNJfqpmN


        TODO: Switch to svg from shitty font icons, Switch to using closest() for some functionality.

            ------old readme------
            ------Might be useful if you are new and want to change the fonts------
            ------old readme------


        To change background color or text color, just replace the style values above with the hex values for the colors you want.
        If you want the background of the counter to remain semi-transparent, you must use rgb values like above. The last number (where I've put 0.8) is the opacity level (1.0 = completely opaque).
        To change font size, just change the em value to what works for you (the standard size is 1, I like it at 1.5).
        To change font weight (boldness), just edit the value above.  100 is quite thin, 400 is default, 900 is quite thick.  You may want it higher than default for Mincho fonts.
        The line-height value changes the spacing between lines.

        To use the font of your choice, remove the list of fonts above and put the ENGLISH name of your font in quotation marks (some JP font names are in Japanese).
        Be sure to leave a semi-colon at the end of the line.
        To find the English name of a given font, first install it, then open Firefox.
        Go to about:preferences#content in the address bar, then click on the 'Default font' drop-down menu.
        The "correct" name of your font will be listed here - just copy that down and paste it up above.

        Note that if you would like to use your browser default font, replace the font-family line with font-family:""; or delete it altogether.
        Your default is probably Gothic - if you want to try out a good Mincho font, try Aozora Mincho at http://www.freejapanesefont.com/aozora-mincho-download/
        For various other free Japanese fonts, visit http://www.freejapanesefont.com/
        For more font attribute information visit http://www.w3schools.com/css/css_font.asp

            ----------------------
            ----------------------
            ----------------------

        */

        //------ Default Options (Useful) ------
        /**
         * autoHideYomichan
         * 
         * true: Allows you to auto-hide the yomichan popup when your mouse is out of the window, false: disabled
         * â— This option requires the setting "Use a secure container around popups" to be off in yomichan's options.
         * 
         * Console command to permanently disable this without editing the line below: 
         * localStorage.setItem("notifyOnNewline", false);
         * 
         * */
        let autoHideYomichan = true;

        //------ Default Options (Useless) ------
        /**
         * pinningEnabled
         * 
         * true: pinning is enabled by default, false: disabled
         * 
         * This option is saved to your localstorage every time you toggle it in the menu.
         * Therefore, you don't have to set this option unless you are or clearing history/cache/localstorage etc. (e.g: Using private browsing mode)
         * 
         * */
        let pinningEnabled = false;

        /**
         * editingEnabled
         * 
         * true: editing is enabled by default, false: disabled
         * 
         * This option is saved to your localstorage every time you toggle it in the menu.
         * Therefore, you don't have to set this option unless you are or clearing history/cache/localstorage etc. (e.g: Using private browsing mode)
         * 
         * */
        let editingEnabled = false;

        //---------------------

        //------ Hidden Features ------
        /**
         * notifyOnNewline
         * 
         * Entering below line in the browser console on this page will enable the notify on new lines hidden feature. 
         * Whenever a new line is added, This symbol âœ” will be flashed on page's title for a short time
         * 
         * To enable it, enter the following line into your console on this page:
         * 
         * localStorage.setItem("notifyOnNewline", true);
         * 
         * You only have to enter this once unless you clear your browser cache/history/etc. or are using private browsing.
         * 
         * To disable, type this into your console: 
         * localStorage.setItem("notifyOnNewline", false);
         * 
         * */
        //-----------------------------

        const historystack = [];
        const historystack_forward = [];
        const maxhistorylength = 1000;
        let pageTitle = document.title;
        let scroll_fix_alignment = 10;
        let scrollOnNewline = "toBottom";
        let notifyOnNewline = false;
        let forgiveHistoryTimes = 0;
        let linecount = 0;
        let editPinnedButtons = false;

        //DOMContentLoaded Start (first load)
        document.addEventListener("DOMContentLoaded", function(event) {
            scrollOnNewline = getIfInLocalStorage("scrollOnNewline", scrollOnNewline);
            notifyOnNewline = getIfInLocalStorage("notifyOnNewline", notifyOnNewline);
            pinningEnabled = getIfInLocalStorage("pinningEnabled", pinningEnabled);
            editingEnabled = getIfInLocalStorage("editingEnabled", editingEnabled);
            autoHideYomichan = getIfInLocalStorage("autoHideYomichan", autoHideYomichan);

            switch (scrollOnNewline) {
                case "disabled":
                    document.querySelector("#scroll_button").style.color = "#595959";
                    document.querySelector("#scroll_button").innerText = "â‡•";
                    break;
                case "toBottom":
                    document.querySelector("#scroll_button").style.color = "";
                    document.querySelector("#scroll_button").innerText = "â‡“";
                    break;
                case "toTop":
                    document.querySelector("#scroll_button").style.color = "";
                    document.querySelector("#scroll_button").innerText = "â‡‘";
                    break;
                default:
                    scrollOnNewline = "toBottom";
                    break;
            }

            //Document Title is different for local and online pages
            if (document.location.protocol.indexOf("http") == -1) {
                document.title = pageTitle += " (Local)";
            } else {
                document.title = pageTitle += " (Online)";
            }
            pageTitle = document.title;

            //load first states
            if (pinningEnabled) {
                togglePinning(true);
            }
            if (editingEnabled) {
                toggleEditing(true);
            }

            //add button events
            //undo_button
            document.getElementById("undo_button").addEventListener("click", function() {
                historyPop();
            });

            //redo_button
            document.getElementById("redo_button").addEventListener("click", function() {
                historyPop_forward();
            });

            //edit_button
            document.getElementById("edit_button").addEventListener("click", function() {
                toggleEditing();
            });

            //add_line_button
            document.getElementById("add_line_button").addEventListener("click", function() {
                addNewLine();
            });

            //pin_button
            document.getElementById("pin_button").addEventListener("click", function() {
                togglePinning();
            });

            //menu_button (normally you hover this one.)
            document.getElementById("menu_button").addEventListener("click", function() {
                togglePinning();
            });

            //scroll_button
            document.getElementById("scroll_button").addEventListener("click", function() {
                switch (scrollOnNewline) {
                    case "disabled":
                        document.querySelector("#scroll_button").style.color = "";
                        document.querySelector("#scroll_button").innerText = "â‡“";
                        scrollOnNewline = "toBottom";
                        break;
                    case "toBottom":
                        document.querySelector("#scroll_button").style.color = "";
                        document.querySelector("#scroll_button").innerText = "â‡‘";
                        scrollOnNewline = "toTop";
                        break;
                    case "toTop":
                        document.querySelector("#scroll_button").style.color = "#595959";
                        document.querySelector("#scroll_button").innerText = "â‡•";
                        scrollOnNewline = "disabled";
                        break;
                    default:
                        scrollOnNewline = "toBottom";
                        break;
                }
                localStorage.setItem("scrollOnNewline", scrollOnNewline);
            });

            document.getElementById("remove_button").addEventListener("click", function() {
                historyPush();

                //Check whether there are any lines.
                //let linecount = document.querySelectorAll('#textlines > pre').length;
                if (linecount > 0) {

                    //Remove the first/last line.
                    switch (scrollOnNewline) {
                        case "disabled":
                            document.querySelector("#textlines > pre:last-of-type").remove();
                            break;
                        case "toBottom":
                            document.querySelector("#textlines > pre:last-of-type").remove();
                            break;
                        case "toTop":
                            document.querySelector("#textlines > pre:first-of-type").remove();
                            break;
                        default:
                            break;
                    }

                    updateCounter();
                };
            });

            document.getElementById("clear_button").addEventListener("click", function(e) {

                //If shift is held, clear history as well.
                if (e.shiftKey) {
                    historystack.length = 0;
                    historystack_forward.length = 0;
                    sethistoryButtons();
                } else {
                    historyPush();
                }

                document.querySelectorAll('#textlines')[0].innerHTML = "";
                //Update the counter.
                updateCounter();
            });

            document.getElementById("go_to_last_button").addEventListener("click", function() {
                //document.querySelector("#textlines > pre:last-of-type").scrollIntoView();
                if (linecount > 0) {
                    window.scroll(0, findPos(document.querySelector("#textlines > pre:last-of-type"))[1] - 200);
                }
            });

            document.getElementById("go_bottom_button").addEventListener("click", function() {
                if (linecount > 0) {
                    document.querySelectorAll("html")[0].scrollIntoView(false);
                }
            });

            //Keyboard shortcuts
            document.addEventListener("keydown", function(e) {
                //Alt + E: Toggle Editing
                if (e.altKey && e.which == 69) {
                    toggleEditing();
                    e.preventDefault();
                }
            });


            //Non-css hover method for the menu
            document.getElementById("menucontainer").addEventListener("mouseenter", function(e) {
                handleMenuState();
            });

            document.getElementById("toprightbuttons").addEventListener("mouseleave", function(e) {
                if (!pinningEnabled) {
                    //document.querySelector("#menucontainer").removeAttribute("style");
                    handleMenuState();
                }
            });

            //start checking for mouse in/out
            if (autoHideYomichan) {
                checkMouseInOut();
            }

            //main mutation observer for new lines.
            const textlinesMutationObserver = new MutationObserver(function(records) {
                records.forEach(function(mutation) {
                    Array.prototype.forEach.call(mutation.addedNodes, function(node) {
                        try {

                            //Compatibility for prepending because some can't be bothered to switch to a modified clipboard inserter that allows prepending.
                            switch (scrollOnNewline) {
                                case "toTop":
                                    let prevSib = node.previousElementSibling;
                                    if (prevSib != null) {
                                        document.querySelector("#textlines").prepend(node);
                                        return;
                                    }
                                    default:
                                        break;
                            }

                            //push history (delete forward history)
                            if (forgiveHistoryTimes == 0) {
                                historyPush();
                            } else {
                                --forgiveHistoryTimes;
                            }

                            //update counter
                            updateCounter();

                            //check if editing is enabled
                            let preNodeOpen = editingEnabled ? "<pre contenteditable=\"true\">" : "<pre>";
                            //put the added pre text into another pre so we can modify it later on.
                            node.innerHTML = preNodeOpen + node.innerHTML + "</pre>";

                            //add hover buttons to every line
                            createhoverButtons(node);

                            //Notify on new line (using document.title)
                            if ((notifyOnNewline) && (document.querySelector('html:hover') == null)) {
                                //console.log(document.querySelector('div:hover'));
                                notifyUsingTitle();
                            }

                            //Scroll to item depending on setting
                            switch (scrollOnNewline) {
                                case "disabled":
                                    break;
                                case "toBottom":
                                    scrollToLast(1);
                                    break;
                                case "toTop":
                                    scrollToLast(0);
                                    break;
                                default:
                                    break;
                            }

                        } catch (e) {}

                    });
                });
            });

            //mutation observer for compatibility. Because its hard to change the options. (read the readme above)
            const compatibilityMutationObserver = new MutationObserver(function(records) {
                records.forEach(function(mutation) {
                    Array.prototype.forEach.call(mutation.addedNodes, function(node) {
                        try {

                            //Everything other than "body > p" is ignored.
                            if ((node.tagName == "P") && (node.parentNode.tagName != "BODY")) {
                                return;
                            }

                            //Get new text
                            let newNode = document.createElement("pre");
                            newNode.innerHTML = node.innerText;

                            //Remove the node
                            node.remove();

                            //Append or prepend the new node depending on the current setting
                            switch (scrollOnNewline) {
                                case "disabled":
                                    document.querySelector("#textlines").append(newNode);
                                    break;
                                case "toBottom":
                                    document.querySelector("#textlines").append(newNode);
                                    break;
                                case "toTop":
                                    document.querySelector("#textlines").prepend(newNode);
                                    break;
                                default:
                                    document.querySelector("#textlines").append(newNode);
                                    break;
                            }


                        } catch (e) {}

                    });
                });
            });

            //start the textlines mutation observer
            textlinesMutationObserver.observe(document.querySelector('#textlines'), {
                childList: true,
                subtree: false
            });

            //start the default options compatibility mutation observer
            compatibilityMutationObserver.observe(document.querySelector('body'), {
                childList: true,
                subtree: false
            });

            /*
            //Test
            newpree = document.createElement("pre");
            newpree.innerHTML = "loremipsum\n\nloremipsumloremipsumloremipsum\n\n\n\nloremipsumloremipsum";
            document.querySelector("#textlines").prepend(newpree);
            */

        });
        //---DOMContentLoaded end---
        //---DOMContentLoaded end---
        //---DOMContentLoaded end---

        //----------functions----------

        //Modified from https://stackoverflow.com/a/24989958/5050478
        //Mouse in/out check for yomichan (with shadow dom disabled in settings)
        function checkMouseInOut() {
            var theTimer;
            var aFrameWasHidden = false;

            //reset or clear the timer on mouse in/out
            window.onmouseout = resetTimer;
            window.onmouseover = clearTimer;

            function doAction() {
                try {
                    //hide yomichan if it exists.
                    let yomichanFrames = document.querySelectorAll("iframe.yomichan-popup");
                    yomichanFrames.forEach(currFrame => {
                        if (currFrame.style.getPropertyValue("visibility") == "visible") {
                            currFrame.style.setProperty("visibility", "hidden", "important");
                            currFrame.classList.add("thisFrameWasHidden");
                            aFrameWasHidden = true;
                        }
                    });
                } catch (error) {}
            }

            function clearTimer(e) {
                //Mouse entered the window or any element
                clearTimeout(theTimer);
                try {
                    if (aFrameWasHidden) {
                        let yomichanFrames = document.querySelectorAll("iframe.yomichan-popup");
                        yomichanFrames.forEach(currFrame => {
                            if (currFrame.classList.contains("thisFrameWasHidden")) {
                                //transition is used to prevent flashing
                                currFrame.style.setProperty("transition", "visibility 0.5s linear 0.5s");
                                currFrame.style.setProperty("visibility", "visible", "important");
                                setTimeout(() => {
                                    currFrame.style.removeProperty("transition");
                                }, 1);
                                currFrame.classList.remove("thisFrameWasHidden");
                                aFrameWasHidden = false;
                            }
                        });
                    }
                } catch (error) {}
            }

            function resetTimer(e) {
                clearTimeout(theTimer);
                let reltarget = e.relatedTarget || e.toElement;
                if (!reltarget || (reltarget.nodeName == "HTML" && e.target == document.firstChild)) {
                    //Mouse left window here, do action 1000 miliseconds after the mouse leaves the window
                    theTimer = setTimeout(doAction, 1000);
                }
            }
        }

        //Get from localstorage if it exists, otherwise keep current value.
        function getIfInLocalStorage(itemName, currentVal) {
            let storedVal = localStorage.getItem(itemName);
            if (storedVal != null) {
                //If the stored value is true or false return those.
                switch (storedVal.toLowerCase()) {
                    case "true":
                        return true;
                    case "false":
                        return false;
                    default:
                        return storedVal;
                }
            } else {
                //No stored value
                return currentVal;
            }
        }

        //handle top right menu container hover state manually (required to support keybindings and transparency)
        function handleMenuState() {
            var menuStyles = window.getComputedStyle(document.querySelector("#menucontainer"));
            var buttonsStyles = window.getComputedStyle(document.querySelector("#toprightbuttons"));
            var menuDisplay = menuStyles.getPropertyValue("display");
            var buttonsDisplay = buttonsStyles.getPropertyValue("display");
            if ((menuDisplay == "block") && (buttonsDisplay == "block")) {
                document.querySelector("#menucontainer").setAttribute("style", "display:none;");
            } else if ((menuDisplay == "none") && (buttonsDisplay == "none")) {
                document.querySelector("#menucontainer").removeAttribute("style");
            }
        }

        //Firefox hover bug workaround: Recheck the menu state when its hidden to prevent it from being hidden permanently.
        let menustateInterval = setInterval(() => {
            //Check when not pinned and hidden manually
            if (!pinningEnabled && document.querySelector('#menucontainer[style="display:none;"]')) {
                handleMenuState();
            }
        }, 175);

        //add hover buttons to every line
        function createhoverButtons(element) {

            let hoverButtons = document.createElement("div");
            element.prepend(hoverButtons);
            hoverButtons.outerHTML = `<div class="hoverButtonsContainer">
<div class="hoverButtonsBackground">
<div class="hoverButtons hoverButtonDelete" title="Remove line">âœ–</div>
<div class="hoverButtons hoverButtonReduceNewlines" title="Reduce newlines and spaces">â‰¡</div>
<div class="hoverButtons hoverButtonCopy" title="Copy to clipboard">ðŸ“‹</div>
<div class="hoverButtons hoverButtonDown" title="Scroll down one line">ðŸ¡»</div>
<div class="hoverButtons hoverButtonUp" title="Scroll up one line">ðŸ¡¹</div>
</div>
</div>`;
            element.querySelector(".hoverButtonDelete").addEventListener("click", function(event) {
                historyPush();

                removeLine(event.target);
            });
            element.querySelector(".hoverButtonReduceNewlines").addEventListener("click", function(event) {
                historyPush();

                reduceNewlines(event.target);
            });
            element.querySelector(".hoverButtonUp").addEventListener("click", function(event) {
                scrollUpDown(event.target, event.clientY, true);
            });
            element.querySelector(".hoverButtonDown").addEventListener("click", function(event) {
                scrollUpDown(event.target, event.clientY, false);
            });
            element.querySelector(".hoverButtonCopy").addEventListener("click", function(event) {
                let range = document.createRange();
                range.selectNode(event.target.parentNode.parentNode.parentNode.querySelector("pre"));
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(range);
                document.execCommand("copy");
                window.getSelection().removeAllRanges();
            });
        }

        //start undo/redo buttons
        function historyPush(resetforward = true) {
            let textlinesNode = document.querySelector("#textlines").cloneNode(true);
            let dummyDiv = document.createElement("div");
            for (const element of textlinesNode.childNodes) {
                try {
                    if (element.firstChild.nodeName != "#text") {
                        let textPre = element.querySelector("pre");
                        //clean up contenteditable
                        textPre.removeAttribute("contenteditable");
                        dummyDiv.append(textPre);
                    }
                } catch {}
            }
            let historydict = {
                state: dummyDiv.innerHTML,
                linecount: textlinesNode.childNodes.length,
            }
            let historylength = historystack.push(historydict);
            if (historylength > maxhistorylength) {
                historystack.shift();
            }
            if (resetforward) {
                //reset forward history
                historystack_forward.length = 0;
            }

            sethistoryButtons();
        }

        function historyPop() {
            historyPush_forward();
            popDict = historystack.pop();
            forgiveHistoryTimes = popDict.linecount;
            document.querySelector("#textlines").innerHTML = popDict.state;

            sethistoryButtons();
            updateCounter();
        }

        function historyPush_forward() {
            let textlinesNode = document.querySelector("#textlines").cloneNode(true);
            let dummyDiv = document.createElement("div");
            for (const element of textlinesNode.childNodes) {
                try {
                    //ignore text only nodes (that were just inserted)
                    if (element.firstChild.nodeName != "#text") {
                        let textPre = element.querySelector("pre");
                        //clean up contenteditable
                        textPre.removeAttribute("contenteditable");
                        dummyDiv.append(textPre);
                    }
                } catch {}
            }
            let historydict = {
                state: dummyDiv.innerHTML,
                linecount: textlinesNode.childNodes.length,
            }
            let historylength_forward = historystack_forward.push(historydict);
            if (historylength_forward > maxhistorylength) {
                historystack_forward.shift();
            }
        }

        function historyPop_forward() {

            historyPush(false);
            popDict = historystack_forward.pop();
            forgiveHistoryTimes = popDict.linecount;
            document.querySelector("#textlines").innerHTML = popDict.state;

            sethistoryButtons();
            updateCounter();
        }

        function sethistoryButtons() {
            if (historystack.length >= 1) {
                document.querySelector("#undo_button").removeAttribute("disabled");
            } else {
                document.querySelector("#undo_button").setAttribute("disabled", "");
            }
            if (historystack_forward.length >= 1) {
                document.querySelector("#redo_button").removeAttribute("disabled");
            } else {
                document.querySelector("#redo_button").setAttribute("disabled", "");
            }
        }
        //end undo/redo buttons

        //toggle editing
        function toggleEditing(firstload = false) {
            if (firstload) {
                editingEnabled = !editingEnabled;
            }
            if (editingEnabled) {
                //disable editing, set button style
                const linesArray = document.querySelectorAll("#textlines>pre>pre").forEach(element => {
                    element.removeAttribute("contenteditable");
                });
                document.querySelector("#edit_button").classList.remove("edit_button_on");
                //also unpin if we pinned it
                if (editPinnedButtons) {
                    togglePinning();
                }
            } else {
                //push to history, enable editing, set button style
                historyPush();
                const linesArray = document.querySelectorAll("#textlines>pre>pre").forEach(element => {
                    element.setAttribute("contenteditable", "true");
                });
                document.querySelector("#edit_button").classList.add("edit_button_on");
                //also pin the buttons as well
                if (document.querySelectorAll(".pin_button_on").length != 1) {
                    togglePinning();
                    editPinnedButtons = true;
                }
            }
            editingEnabled = !editingEnabled;
            localStorage.setItem("editingEnabled", editingEnabled);
        }

        //add new line
        function addNewLine() {
            if (!editingEnabled) {
                toggleEditing();
            }

            newpre = document.createElement("pre");
            newpre.innerHTML = "";
            //append or prepend the new line based on the current setting, prepend is default.
            switch (scrollOnNewline) {
                case "disabled":
                    document.querySelector("#textlines").prepend(newpre);
                    break;
                case "toBottom":
                    document.querySelector("#textlines").append(newpre);
                    break;
                case "toTop":
                    document.querySelector("#textlines").prepend(newpre);
                    break;
                default:
                    document.querySelector("#textlines").prepend(newpre);
                    break;
            }
            //Workaround for focusing contenteditable (https://stackoverflow.com/a/37162116/5050478)
            setTimeout(function() {
                newpre.querySelector("pre").focus();
            }, 0);

        }

        //toggle pinning
        function togglePinning(firstload = false) {
            if (firstload) {
                pinningEnabled = !pinningEnabled;
            }
            if (pinningEnabled) {
                document.querySelector("#toprightbuttons").removeAttribute("style");
                document.querySelector("#pin_button").classList.remove("pin_button_on");
                editPinnedButtons = false;
            } else {
                document.querySelector("#toprightbuttons").setAttribute("style", "display:inline-block;");
                document.querySelector("#pin_button").classList.add("pin_button_on");
            }
            //handle menu button visibility (for edge cases)
            handleMenuState();
            pinningEnabled = !pinningEnabled;
            localStorage.setItem("pinningEnabled", pinningEnabled);
        }

        //notify new lines with a document.title change
        function notifyUsingTitle() {
            //Add notification icon
            document.title = "âœ” " + pageTitle;

            //Blink the icon
            setTimeout(() => {
                document.title = "â˜‘ " + pageTitle;
            }, 150);
            setTimeout(() => {
                document.title = "âœ” " + pageTitle;
            }, 300);
            setTimeout(() => {
                document.title = "â˜‘ " + pageTitle;
            }, 450);
            setTimeout(() => {
                document.title = "âœ” " + pageTitle;
            }, 600);
            setTimeout(() => {
                document.title = "â˜‘ " + pageTitle;
            }, 750);

            //Go back to the original title
            setTimeout(() => {
                document.title = pageTitle;
            }, 900);
        }

        //scrolling
        function scrollToLast(tolast) {
            if (tolast) {
                window.scroll(0, findPos(document.querySelector("#textlines > pre:last-of-type"))[1] - 280);
            } else {
                window.scroll(0, 0);
            }
        }

        function scrollUpDown(element, clientY, scrollUp) {
            //get the pre
            element = element.parentNode.parentNode.parentNode;
            let scrollto = null;
            try {
                if (scrollUp) {
                    scrollto = element.previousElementSibling;
                } else {
                    scrollto = element.nextElementSibling;
                }
                if (scrollto == null) {
                    if (scrollUp) {
                        document.querySelectorAll("html")[0].scrollIntoView(true);
                    } else {
                        document.querySelectorAll("html")[0].scrollIntoView(false);
                    }
                } else {
                    //fix scroll difference from reality
                    window.scroll(0, findPos(scrollto)[1] - clientY - scroll_fix_alignment);
                    //scrollto.scrollIntoView();
                }
                return;
            } catch (error) {}
        }

        //find an element's position in the whole page
        function findPos(obj) {
            let curleft = curtop = 0;
            if (obj.offsetParent) {
                do {
                    curleft += obj.offsetLeft;
                    curtop += obj.offsetTop;
                } while (obj = obj.offsetParent);
                values = [curleft, curtop];
                return values;
            }
        }

        function removeLine(element) {
            element = element.parentNode.parentNode.parentNode;
            element.remove();
            updateCounter();
        }

        function reduceNewlines(element) {
            element = element.parentNode.parentNode.parentNode;
            let modifystring = element.querySelector("pre").innerText;
            //trim newline+spaces at the start (once)
            modifystring = modifystring.replace(/^[\r\t\f\v ã€€\u00a0]*\n/, "");
            //trim spaces+newline at the end (once)
            modifystring = modifystring.replace(/[\r\t\f\v ã€€\u00a0]*\n$/, "");
            //clean spaces
            modifystring = modifystring.replace(/\n[\r\t\f\v ã€€\u00a0]*/gm, "\n");
            //reduce newlines (2->1, 1->0 etc...)
            modifystring = modifystring.replace(/(\n(\n+?))|(\n+?)/gm, "$2$3");
            element.querySelector("pre").innerText = modifystring;
        }

        function updateCounter() {
            let charlength = 0;
            linecount = 0;
            try {
                document.querySelectorAll("#textlines > pre").forEach(element => {
                    charlength += element.innerText.length;
                    linecount++;
                });
            } catch (error) {}
            document.querySelector("#counter").textContent = charlength + ' / ' + linecount;
            return;
        }

    </script>

    <style id="maincss" type="text/css">
        html {
            overflow-y: scroll;
            scrollbar-width: thin;
        }

        body {
            margin-top: 24px;
            margin-left: 2%;
            margin-right: 2%;
            margin-bottom: 420px;
            background-color: #202020;
            color: #BCBCBC;
            font-size: 1.3em;
            font-weight: 400;
            font-family: "MS Gothic", "Meiryo";
            /* font-family: "IPAGothic", "Sazanami Gothic", "Kochi Gothic", "VL Gothic", "Ume Gothic", "Pro W3", "Hiragino Kaku Gothic Pro", "Osaka Mono", "Osaka", "MS Gothic", "Meiryo", "M+ 1m"; */
        }

        /* Main text style */
        pre {
            /* You can pick some other fonts from below as well. Most fonts use MS Gothic for Japanese text (like Segoe UI here) which is the default japanese font for many games and other media. */
            /*font-family: "IPAGothic", "Sazanami Gothic", "Kochi Gothic", "VL Gothic", "Ume Gothic", "Pro W3", "Hiragino Kaku Gothic Pro", "Osaka Mono", "Osaka", "MS Gothic", "Meiryo", "M+ 1m";*/
            /* font-family: "Segoe UI"; */
            font-family: "Noto Sans JP Light";
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0em 0em 0em 0em;
            padding-bottom: 0px;
        }

        #textlines>pre {
            border-bottom: #414141 solid 1px;
            padding-bottom: 1.4em;
            margin-bottom: 0.46em;
        }

        /* Preemptively hide compatibility lines to prevent flashing */
        body>p {
            display: none;
        }

        /* Top right buttons & counter css */
        .countercontainer {
            bottom: 1px;
            right: 1px;
            position: fixed;
            display: inline-block;
            font-size: 1.4em;
            user-select: none;
        }

        #counter {
            font-size: 11px;
            padding: 4px 6px 4px 6px !important;
            margin-right: 0px;
            border-radius: 4px !important;
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            line-height: 100%;
            float: left;
            font-family: "Calibri";
        }

        .buttoncontainer {
            right: 1px;
            top: 1px;
            position: fixed;
            display: inline-block;
            font-family: "VL Gothic";
            user-select: none;
            z-index: 1;
        }

        #toprightbuttons:hover,
        #menucontainer:hover~#toprightbuttons {
            display: inline-block !important;
        }

        #toprightbuttons {
            z-index: 3;
            display: none;
        }

        .buttoncontainer>div:not(#counter):hover {
            color: #d7d7d7;
            fill: #d7d7d7;
            background-color: rgba(27, 27, 27, 1.00);
        }

        .buttoncontainer>#pin_button:hover {
            filter: brightness(140%) grayscale(100%);
            background-color: rgba(19, 19, 19, 1.00) !important;
        }

        .buttoncontainer>div,
        .countercontainer>div {
            border-radius: 4px !important;
            margin-right: 5px;
        }

        #pin_button {
            padding: 2px 3px 5px 4px;
            font-size: 10px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            float: left;
            cursor: pointer;
            filter: grayscale(100%);
            font-family: "Segoe UI", "Noto Sans JP Light", "Arial";
        }

        .pin_button_on>#pintext {
            transform: rotate(-45deg) !important;
            margin-right: 1px;
            margin-left: -1px;
        }

        #clear_button {
            font-size: 13px;
            padding: 0px 4px 2px 4px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            float: left;
            cursor: pointer;
            font-family: "Noto Sans JP Light", "Arial";
        }

        #scroll_button {
            font-size: 14px;
            padding: 1px 3px 2px 4px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #a6a6a6;
            float: left;
            cursor: pointer;
            /*font-family: "Lucida Sans Unicode";*/
        }

        #edit_button {
            font-size: 13px;
            padding: 1px 4px 2px 4px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            float: left;
            cursor: pointer;
        }

        .edit_button_on {
            box-shadow: inset 0px 0px 6px 2px rgba(73, 196, 47, 0.5);
            color: rgb(73, 196, 47) !important;
        }

        #add_line_button {
            background-color: rgba(25, 25, 25, 0.65);
            float: left;
            cursor: pointer;
            padding: 3px 4px 4px 4px;
            width: 14px;
            fill: #9f9f9f;
        }

        .undoredoButtons {
            background-color: rgba(25, 25, 25, 0.65);
            color: #848484;
            font-size: 15px;
            height: 10px;
            width: 10px;
            float: left;
            padding: 5px 0px 6px 6px;
            cursor: pointer;
            pointer-events: initial;
        }

        .undoredoButtons>div:hover,
        #remove_button:hover {
            color: #ccc !important;
        }

        .undoredoButtons[disabled] {
            pointer-events: none;
            color: #4e4e4e;
        }

        #undo_button {
            margin-right: 0px;
            padding-right: 3px;
            border-radius: 4px 0px 0px 4px !important;
        }

        #redo_button {
            border-radius: 0px 4px 4px 0px !important;
            padding-left: 3px;
            padding-right: 6px;
        }

        #menu_button {
            background-color: rgba(25, 25, 25, 0.65);
            color: #9d9d9d;
            float: right;
            font-size: 16px;
            padding: 0px 4px 1px 4px;
            margin-right: 0px;
            cursor: pointer;
            line-height: 20px;
        }

        #remove_button {
            padding: 1px 3px 1px 3px;
            background-color: rgba(25, 25, 25, 0.65);
            color: #868686;
            float: right;
            font-size: 15px;
            margin-right: 0px;
            cursor: pointer;
        }

        /* Top/Bottom buttons css */
        #go_to_last_button {
            margin-left: 88px;
            bottom: -20px;

            position: relative;
            cursor: pointer;
            user-select: none;
            font-size: 22px;
            width: 24px;
            filter: opacity(20%);
        }

        #go_to_last_button:hover {
            filter: opacity(40%);
        }

        #go_bottom_button {
            margin-left: 88px;
            top: -6px !important;
            position: absolute;
            cursor: pointer;
            user-select: none;
            font-size: 22px;
            width: 24px;
            filter: opacity(20%);
        }

        #go_bottom_button:hover {
            filter: opacity(40%);
        }

        /* Hover buttons CSS */
        .hoverButtonsContainer {
            width: 88px;
            margin-top: -20px;
            height: 20px;
            position: absolute;
            display: flex;
            background-color: transparent;
            user-select: none;
        }

        .hoverButtonsContainer:hover,
        pre:hover>.hoverButtonsContainer>.hoverButtonsBackground {
            display: flex !important;
        }

        .hoverButtonsBackground:hover,
        .hoverButtonsBackground:hover>.hoverButtons {
            opacity: 90%;
        }

        .hoverButtonsBackground {
            height: 15px;
            padding: 2px 4px 5px 10px;
            border-radius: 6px;
            position: absolute;
            display: flex;
            flex-direction: row;
            justify-content: space-evenly;
            background-color: #1D1D1D;
            z-index: 555;
            font-size: 14px;
            user-select: none;
            display: none;
        }

        .hoverButtons {
            cursor: pointer;
            margin-right: 0px;
            color: #adadad;
            opacity: 40%;
        }

        .hoverButtons:hover {
            color: #fff;
        }

        .hoverButtonDelete {
            font-size: 17px;
            margin-right: 3px;
            margin-top: -5px;
            margin-left: -5px;
        }

        .hoverButtonReduceNewlines {
            margin-top: -9px;
            margin-right: 1px;
            font-size: 22px;
            font-family: Segoe UI;
            font-weight: bold;
        }

        .hoverButtonCopy:hover {
            filter: contrast(170%);
        }

        .hoverButtonCopy {
            margin-top: -1px;
            margin-right: 1px;

            font-size: 13px;
            font-family: Arial;
            filter: contrast(90%);
        }

        .hoverButtonDown,
        .hoverButtonUp {
            font-size: 14px;
            margin-top: -2px;
        }

        /* Webkit compatibility: Thinner Scrollbar (similar to Firefox) */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: #7a7a7b !important;
        }

        ::-webkit-scrollbar-track {
            background: #232327;
        }

        /* Lighter background colors for buttons */
        /* 
        .buttoncontainer>div,
        .hoverButtonsBackground {
            background-color: rgb(60, 60, 60) !important;
        }
        */

    </style>

</head>

<body>
    <div id="go_bottom_button" title="Scroll to the bottom">ðŸ¡»</div>
    <div id="menucontainer" class="buttoncontainer">
        <!-- This is the div used for the "show menu menu" button. -->
        <div id="menu_button" title="Menu">âš™</div>
    </div>
    <div id="toprightbuttons" class="buttoncontainer">
        <!-- This is the div used for the "Pin menu" button. -->
        <div id="pin_button" title="Pin/Unpin the menu">
            <div id="pintext">ðŸ“Œ</div>
        </div>
        <!-- This is the div used for the "Clear all lines" button. ðŸ›‡âŠ˜âˆ… -->
        <div id="clear_button" title="Clear all lines.
Clears the history as well when clicked while holding Shift.">âŠ˜</div>
        <!-- This is the div used for the "Toggle scroll to bottom a when new line is added" button. -->
        <div id="scroll_button" title="Scroll to bottom(â‡“)/top(â‡‘)/nowhere(â‡•) when a new line is added.
Also prepends new lines by default if set to top(â‡‘).">â‡“</div>
        <!-- This is the div used for the "Enable editing" button. -->
        <div id="edit_button" title="Enables line editing.
History is saved right when you enable this,
so disable it if you want when you are done.
Toggle Shortcut: Alt + E">ðŸ–‰</div>
        <!-- This is the div used for the "Add a new line" button. -->
        <div id="add_line_button" title="Adds a new line and enables editing.
Saves history when pressed.">
            <!-- Octicons v11.0.0, License: MIT, Copyright (c) 2020 GitHub Inc. -->
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M8 2a.75.75 0 01.75.75v4.5h4.5a.75.75 0 010 1.5h-4.5v4.5a.75.75 0 01-1.5 0v-4.5h-4.5a.75.75 0 010-1.5h4.5v-4.5A.75.75 0 018 2z"></path>
            </svg>
        </div>
        <!-- These are the divs used for the "Undo/Redo" buttons. -->
        <div id="undo_button" class="undoredoButtons" disabled="" title="Undo">
            <div>
                <!-- Font Awesome Icons, CC BY 4.0 License, https://fontawesome.com/license/free -->
                <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="undo-alt" class="svg-inline--fa fa-undo-alt fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z"></path>
                </svg>
            </div>
        </div>
        <div id="redo_button" class="undoredoButtons" disabled="" title="Redo">
            <div>
                <!-- Font Awesome Icons, CC BY 4.0 License, https://fontawesome.com/license/free -->
                <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="redo-alt" class="svg-inline--fa fa-redo-alt fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z"></path>
                </svg>
            </div>
        </div>
        <!-- This is the div used for the "remove last line" button. -->
        <div id="remove_button" title="Remove first/last line
Removes the first line when auto scroll is set to 'Scroll to top(â‡‘)'">âœ–</div>
    </div>
    <div class="countercontainer">
        <!-- This is the div used for the counter. -->
        <div id="counter" title="No. of characters / No. of lines">0 / 0</div>
    </div>
    <div style="display:none;">
        <!-- Dummy div for buttons-->
    </div>

    <!-- inserted pre tags go here -->
    <div id="textlines"></div>

    <div id="go_to_last_button" title="Scroll to the start of the last item">ðŸ¡¹</div>

</body>

</html>
